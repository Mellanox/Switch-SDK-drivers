From 0586979ebd57a735934e13c2a549b6457c83f8b7 Mon Sep 17 00:00:00 2001
From: Zhengfeng Dou <zhengfengd@nvidia.com>
Date: Wed, 28 Jun 2023 15:18:31 +0800
Subject: [PATCH] drop_monitor: Extend WJH buffer linux channel

SDK WJH-Libs is using following information for shared buffer drops:
* egress_port
* tc
* egress_port_valid
* original_occupancy
* original_latency
* drop_reason.id

The above metadata is missing when using linux channel (drop monitor).
This patch is to add the extended information also for linux channel.
---
 include/net/drop_monitor.h       |  18 +++++
 include/uapi/linux/net_dropmon.h |   5 ++
 net/core/drop_monitor.c          | 111 +++++++++++++++++++++++++++++++
 3 files changed, 134 insertions(+)
 mode change 100644 => 100755 include/net/drop_monitor.h
 mode change 100644 => 100755 include/uapi/linux/net_dropmon.h
 mode change 100644 => 100755 net/core/drop_monitor.c

diff --git a/include/net/drop_monitor.h b/include/net/drop_monitor.h
old mode 100644
new mode 100755
index 3f5b6ddb3..b6339fd50
--- a/include/net/drop_monitor.h
+++ b/include/net/drop_monitor.h
@@ -8,18 +8,36 @@
 #include <linux/skbuff.h>
 #include <net/flow_offload.h>
 
+#ifndef SX_EXTEND_WJH_BUFFER_LINUX_CHANNEL
+#define SX_EXTEND_WJH_BUFFER_LINUX_CHANNEL
+#endif
+
 /**
  * struct net_dm_hw_metadata - Hardware-supplied packet metadata.
  * @trap_group_name: Hardware trap group name.
  * @trap_name: Hardware trap name.
  * @input_dev: Input netdevice.
  * @fa_cookie: Flow action user cookie.
+ * @output_port_dev: Output port netdevice.
+ * @output_lag_dev: Output lag netdevice.
+ * @out_tc: Output port tclass.
+ * @out_tc_occ: Output port tclass buffer occupancy.
+ * @latency: End-to-end latency.
  */
 struct net_dm_hw_metadata {
 	const char *trap_group_name;
 	const char *trap_name;
 	struct net_device *input_dev;
 	const struct flow_action_cookie *fa_cookie;
+	struct net_device *output_port_dev;
+	struct net_device *output_lag_dev;
+	u16 out_tc;
+	u64 out_tc_occ;
+	u64 latency;
+	u8 out_tc_valid:1,
+	   out_tc_occ_valid:1,
+	   latency_valid:1,
+	   unused:5;
 };
 
 #if IS_REACHABLE(CONFIG_NET_DROP_MONITOR)
diff --git a/include/uapi/linux/net_dropmon.h b/include/uapi/linux/net_dropmon.h
old mode 100644
new mode 100755
index 66048cc5d..6afabc7a7
--- a/include/uapi/linux/net_dropmon.h
+++ b/include/uapi/linux/net_dropmon.h
@@ -93,6 +93,11 @@ enum net_dm_attr {
 	NET_DM_ATTR_SW_DROPS,			/* flag */
 	NET_DM_ATTR_HW_DROPS,			/* flag */
 	NET_DM_ATTR_FLOW_ACTION_COOKIE,		/* binary */
+	NET_DM_ATTR_OUT_PORT,			/* nested */
+	NET_DM_ATTR_OUT_LAG,			/* nested */
+	NET_DM_ATTR_OUT_TC,			/* u16 */
+	NET_DM_ATTR_OUT_TC_OCC,			/* u64 */
+	NET_DM_ATTR_LATENCY,			/* u64 */
 
 	__NET_DM_ATTR_MAX,
 	NET_DM_ATTR_MAX = __NET_DM_ATTR_MAX - 1
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
old mode 100644
new mode 100755
index fdf1c6f41..202ccdb67
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -592,6 +592,36 @@ static int net_dm_packet_report_in_port_put(struct sk_buff *msg, int ifindex,
 	return -EMSGSIZE;
 }
 
+static int net_dm_packet_report_out_port_put(struct sk_buff *msg, int ifindex,
+                                           const char *name, bool is_lag)
+{
+	struct nlattr *attr;
+	int            attrtype = NET_DM_ATTR_OUT_PORT;
+
+	if (is_lag) {
+		attrtype = NET_DM_ATTR_OUT_LAG;
+	}
+
+	attr = nla_nest_start(msg, attrtype);
+	if (!attr)
+		return -EMSGSIZE;
+
+	if (ifindex &&
+		nla_put_u32(msg, NET_DM_ATTR_PORT_NETDEV_IFINDEX, ifindex))
+		goto nla_put_failure;
+
+	if (name && nla_put_string(msg, NET_DM_ATTR_PORT_NETDEV_NAME, name))
+		goto nla_put_failure;
+
+	nla_nest_end(msg, attr);
+
+	return 0;
+
+nla_put_failure:
+       nla_nest_cancel(msg, attr);
+       return -EMSGSIZE;
+}
+
 static int net_dm_packet_report_fill(struct sk_buff *msg, struct sk_buff *skb,
 				     size_t payload_len)
 {
@@ -710,6 +740,16 @@ net_dm_flow_action_cookie_size(const struct net_dm_hw_metadata *hw_metadata)
 	       nla_total_size(hw_metadata->fa_cookie->cookie_len) : 0;
 }
 
+static size_t net_dm_out_port_size(void)
+{
+	/* NET_DM_ATTR_OUT_PORT nest */
+	return nla_total_size(0) +
+			/* NET_DM_ATTR_PORT_NETDEV_IFINDEX */
+			nla_total_size(sizeof(u32)) +
+			/* NET_DM_ATTR_PORT_NETDEV_NAME */
+			nla_total_size(IFNAMSIZ + 1);
+}
+
 static size_t
 net_dm_hw_packet_report_size(size_t payload_len,
 			     const struct net_dm_hw_metadata *hw_metadata)
@@ -735,6 +775,16 @@ net_dm_hw_packet_report_size(size_t payload_len,
 	       nla_total_size(sizeof(u32)) +
 	       /* NET_DM_ATTR_PROTO */
 	       nla_total_size(sizeof(u16)) +
+	       /* NET_DM_ATTR_OUT_PORT */
+	       net_dm_out_port_size() +
+	       /* NET_DM_ATTR_OUT_LAG */
+	       net_dm_out_port_size() +
+	       /* NET_DM_ATTR_OUT_TC */
+	       nla_total_size(sizeof(u16)) +
+	       /* NET_DM_ATTR_OUT_TC_OCC */
+	       nla_total_size(sizeof(u64)) +
+	       /* NET_DM_ATTR_LATENCY */
+	       nla_total_size(sizeof(u64)) +
 	       /* NET_DM_ATTR_PAYLOAD */
 	       nla_total_size(payload_len);
 }
@@ -780,6 +830,43 @@ static int net_dm_hw_packet_report_fill(struct sk_buff *msg,
 		    hw_metadata->fa_cookie->cookie))
 		goto nla_put_failure;
 
+	if (hw_metadata->output_port_dev) {
+		struct net_device *dev = hw_metadata->output_port_dev;
+		int rc;
+
+		rc = net_dm_packet_report_out_port_put(msg, dev->ifindex,
+						       dev->name, false);
+		if (rc)
+			goto nla_put_failure;
+	}
+
+	if (hw_metadata->output_lag_dev) {
+		struct net_device *dev = hw_metadata->output_lag_dev;
+		int rc;
+
+		rc = net_dm_packet_report_out_port_put(msg, dev->ifindex,
+						       dev->name, true);
+		if (rc)
+			goto nla_put_failure;
+	}
+
+	if (hw_metadata->out_tc_valid) {
+		if (nla_put_u16(msg, NET_DM_ATTR_OUT_TC, hw_metadata->out_tc))
+			goto nla_put_failure;
+	}
+
+	if (hw_metadata->out_tc_occ_valid) {
+		if (nla_put_u64_64bit(msg, NET_DM_ATTR_OUT_TC_OCC,
+							  hw_metadata->out_tc_occ, NET_DM_ATTR_PAD))
+			goto nla_put_failure;
+	}
+
+	if (hw_metadata->latency_valid) {
+		if (nla_put_u64_64bit(msg, NET_DM_ATTR_LATENCY,
+							  hw_metadata->latency, NET_DM_ATTR_PAD))
+			goto nla_put_failure;
+	}
+
 	if (nla_put_u64_64bit(msg, NET_DM_ATTR_TIMESTAMP,
 			      ktime_to_ns(skb->tstamp), NET_DM_ATTR_PAD))
 		goto nla_put_failure;
@@ -846,6 +933,26 @@ net_dm_hw_metadata_clone(const struct net_dm_hw_metadata *hw_metadata)
 	if (n_hw_metadata->input_dev)
 		dev_hold(n_hw_metadata->input_dev);
 
+	n_hw_metadata->output_port_dev = hw_metadata->output_port_dev;
+	if (n_hw_metadata->output_port_dev)
+		dev_hold(n_hw_metadata->output_port_dev);
+
+	n_hw_metadata->output_lag_dev = hw_metadata->output_lag_dev;
+	if (n_hw_metadata->output_lag_dev)
+		dev_hold(n_hw_metadata->output_lag_dev);
+
+	n_hw_metadata->out_tc_valid = hw_metadata->out_tc_valid;
+	if (n_hw_metadata->out_tc_valid)
+		n_hw_metadata->out_tc = hw_metadata->out_tc;
+
+	n_hw_metadata->out_tc_occ_valid = hw_metadata->out_tc_occ_valid;
+	if (n_hw_metadata->out_tc_occ_valid)
+		n_hw_metadata->out_tc_occ = hw_metadata->out_tc_occ;
+
+	n_hw_metadata->latency_valid = hw_metadata->latency_valid;
+	if (n_hw_metadata->latency_valid)
+		n_hw_metadata->latency = hw_metadata->latency;
+
 	return n_hw_metadata;
 
 free_trap_name:
@@ -862,6 +969,10 @@ net_dm_hw_metadata_free(const struct net_dm_hw_metadata *hw_metadata)
 {
 	if (hw_metadata->input_dev)
 		dev_put(hw_metadata->input_dev);
+	if (hw_metadata->output_port_dev)
+		dev_put(hw_metadata->output_port_dev);
+	if (hw_metadata->output_lag_dev)
+		dev_put(hw_metadata->output_lag_dev);
 	kfree(hw_metadata->fa_cookie);
 	kfree(hw_metadata->trap_name);
 	kfree(hw_metadata->trap_group_name);
-- 
2.30.2

