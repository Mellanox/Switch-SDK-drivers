/*
 * Copyright (c) 2010-2019,  Mellanox Technologies. All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directory of this source tree, or the
 * OpenIB.org BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/kallsyms.h>
#include <linux/mlx_sx/kernel_user.h>
#include "sx.h"
#include "alloc.h"
#include "mmap.h"
#include "sx_dbg_dump_proc.h"

/************************************************
 *  MACROS
 ***********************************************/

#define DBG_DUMP_BUFF_SIZE 80
#define SEQ_FILE_SIZE      (64 * 1024)
#define FROM_BITS_TO_U64(bits) \
    (((bits) %                 \
      64) ? ((bits) / 64) + 1 : ((bits) / 64))

/************************************************
 *  GLOBAL VARIABLES
 ***********************************************/

extern struct sx_globals sx_glb;
extern const char       *ku_pkt_type_str[];

/************************************************
 *  LOCAL VARIABLES
 ***********************************************/
struct proc_dir_entry *__root_dir = NULL;
static u8              sx_dbg_dump_proc_registered = 0;
static struct mutex    __proc_list_lock;
static LIST_HEAD(__proc_list);

struct proc_info {
    struct list_head        list;
    dbg_dump_proc_show_cb_t show_cb;
    dbg_dump_proc_size_cb_t size_cb;
    char                   *name;
};

#define TRAP_UNKNOWN_STR       "Unknown"
#define TRAP_ACL_OR_ROUTER_STR "ACL or Router trap"
#define TRAP_ANY_STR           "Any trap"

/*
 * trap_ids string is defined as static string array because traps range isn't continuous
 */
static const char * const sxd_trap_id_str_s[] = {
    /* GENERAL */
    [SXD_TRAP_ID_GENERAL_FDB] = "SXD_GENERAL_FDB",           /**< FDB */
    [SXD_TRAP_ID_GENERAL_DR_IPC] = "SXD_DR_IPC",      /**< DR IPC */
    [SXD_TRAP_ID_GENERAL_DR_RES] = "SXD_DR_RES",      /**< DR RES */
    [SXD_TRAP_ID_GENERAL_ETH_EMAD] = "SXD_ETH_EMAD",   /**< ETHERNET EMAD */
    [SXD_TRAP_ID_FDB] = "SXD_FDB",                     /**< FDB TRAP */

    /* EVENTS */
    [SXD_TRAP_ID_PUDE] = "SXD_PUDE",                   /**< port up/down*/
    [SXD_TRAP_ID_PMPE] = "SXD_PMPE",                   /**< port module plug / unplug */
    [SXD_TRAP_ID_FLAE] = "SXD_FLAE",                   /**< FDB learning and aging event */
    [SXD_TRAP_ID_FORE] = "SXD_FORE",                   /**< Fan Out of Rang event generated by hardware */
    [SXD_TRAP_ID_TMPW] = "SXD_TMPW",                   /**< Temperature warning event */
    [SXD_TRAP_ID_CPUWD] = "SXD_CPUWD",                 /**< CPU Watchdog Event */
    [SXD_TRAP_ID_PPBME] = "SXD_PPBME",                  /**< BER monitor trap */
    [SXD_TRAP_ID_PACKET_RECEIVED] = "SXD_PACKET_RECEIVED",
    [SXD_TRAP_ID_MFDE] = "SXD_MFDE",                   /**< FW MFDE (FW_SOS) */
    [SXD_TRAP_ID_MOCS_DONE] = "SXD_TRAP_ID_MOCS_DONE", /**< MOCS DONE (Bulk counters) */
    [SXD_TRAP_ID_PPCNT] = "SXD_TRAP_ID_PPCNT", /**< PPCNT (Bulk counters) */
    [SXD_TRAP_ID_MGPCB] = "SXD_TRAP_ID_MGPCB", /**< MGPCB (Bulk counters) */
    [SXD_TRAP_ID_PBSR] = "SXD_TRAP_ID_PBSR", /**< PBSR (Bulk counters) */
    [SXD_TRAP_ID_SBSRD] = "SXD_TRAP_ID_SBSRD", /**< SBSRD (Bulk counters) */
    [SXD_TRAP_ID_BULK_COUNTER_DONE_EVENT] = "SXD_TRAP_ID_BULK_COUNTER_DONE_EVENT", /**< MOCS DONE SW Event (Bulk counters) */

    /* ETHERNET L2 */
    [SXD_TRAP_ID_ETH_L2_STP] = "SXD_STP",                /**< ETHERNET L2 STP */
    [SXD_TRAP_ID_ETH_L2_LACP] = "SXD_LACP",               /**< ETHERNET L2 LACP */
    [SXD_TRAP_ID_ETH_L2_EAPOL] = "SXD_EAPOL",              /**< ETHERNET L2 EAPOL */
    [SXD_TRAP_ID_ETH_L2_LLDP] = "SXD_LLDP",               /**< ETHERNET L2 LLDP */
    [SXD_TRAP_ID_ETH_L2_MMRP] = "SXD_MMRP",               /**< ETHERNET L2 MMRP */
    [SXD_TRAP_ID_ETH_L2_MVRP] = "SXD_MVRP",               /**< ETHERNET L2 MVRP */
    [SXD_TRAP_ID_ETH_L2_RPVST] = "SXD_RPVST",              /**< ETHERNET L2 RPVST */

    /* PTP traps */
    [SXD_TRAP_ID_PTP_PTP0] = "SXD_PTP0_EVENT",
    [SXD_TRAP_ID_PTP_PTP1] = "SXD_PTP1_GENERAL",
    [SXD_TRAP_ID_PTP_ING_EVENT] = "SXD_PTP_ING_EVENT",
    [SXD_TRAP_ID_PTP_EGR_EVENT] = "SXD_PTP_EGR_EVENT",

    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_QUERY] = "SXD_IGMP_QUERY",    /**< ETHERNET L2 IGMP QUERY */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V1_REPORT] = "SXD_IGMP_V1_REPORT", /**< ETHERNET L2 IGMP V1_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_REPORT] = "SXD_IGMP_V2_REPORT", /**< ETHERNET L2 IGMP V2_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V3_REPORT] = "SXD_IGMP_V3_REPORT", /**< ETHERNET L2 IGMP V3_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_LEAVE] = "SXD_IGMP_V2_LEAVE", /**< ETHERNET L2 IGMP V2_LEAVE */
    [SXD_TRAP_ID_ETH_L2_UDLD] = "SXD_UDLD",               /**< ETHERNET UDLD */
    [SXD_TRAP_ID_ETH_L2_DHCP] = "SXD_L2_DHCP",               /**< ETHERNET L2 DHCP */
    [SXD_TRAP_ID_ETH_L2_DHCPV6] = "SXD_L2_DHCPV6",               /**< ETHERNET L2 DHCP V6 */
    [SXD_TRAP_ID_ETH_CONF_TYPE0] = "SXD_ETH_CONF_TYPE0",
    [SXD_TRAP_ID_ETH_CONF_TYPE1] = "SXD_ETH_CONF_TYPE1",
    [SXD_TRAP_ID_ETH_L2_PKT_SAMPLE] = "SXD_PACKET_SAMPLE",    /**< ETHERNET L2 PACKET_SAMPLING */
    [SXD_TRAP_ID_FDB_MISS] = "SXD_FDB_MISS",
    [SXD_TRAP_ID_FDB_MISMATCH] = "SXD_FDB_MISMATCH",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE0] = "SXD_ICMPV6_CONF_TYPE0",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE1] = "SXD_ICMPV6_CONF_TYPE1",
    [SXD_TRAP_ID_OVERLAY_ICMPV6_CONF_TYPE] = "SXD_OVERLAY_ICMPV6_CONF_TYPE",
    [SXD_TRAP_ID_RARP_OPCODES] = "SXD_RARP_OPCODES",       /**< ETHERNET L2 RARP OPCODES */

    /* FCoE */
    [SXD_TRAP_ID_FCOE_FIP] = "SXD_FCOE_FIP",

    /* Telemetry threshold crossing */
    [SXD_TRAP_ID_SB_CONG_TX_PORT] = "SXD_SB_CONG_TX_PORT",

    /* ECN */
    [SXD_TRAP_ID_DECAP_ECN0] = "SXD_DECAP_ECN0",                /**< NVE/IPinIP/MPLS ECN0 */
    [SXD_TRAP_ID_DECAP_ECN1] = "SXD_DECAP_ECN1",                /**< NVE/IPinIP/MPLS ECN1 */

    /* Router */
    [SXD_TRAP_ID_ARP_REQUEST] = "SXD_ARP_REQUEST",               /**< ARP REQUEST */
    [SXD_TRAP_ID_ARP_RESPONSE] = "SXD_ARP_RESPONSE",              /**< ARP RESPONSE */
    [SXD_TRAP_ID_ETH_L3_MTUERROR] = "SXD_L3_MTUERROR",              /**< Packet exceed router interface MTU */
    [SXD_TRAP_ID_ETH_L3_TTLERROR] = "SXD_L3_TTLERROR",              /**< Time To Live (TTL, Expired */
    [SXD_TRAP_ID_ETH_L3_LBERROR] = "SXD_L3_LBERROR",
    [SXD_TRAP_ID_OSPF] = "SXD_OSPF",
    [SXD_TRAP_ID_RIP_V1] = "SXD_RIP_V1",
    [SXD_TRAP_ID_RIP_V2] = "SXD_RIP_V2",
    [SXD_TRAP_ID_PIM] = "SXD_PIM",
    [SXD_TRAP_ID_VRRP] = "SXD_VRRP",
    [SXD_TRAP_ID_VRRP_IPV6] = "SXD_VRRP_IPV6",
    [SXD_TRAP_ID_RESERVED_MC] = "SXD_RESERVED_MC",
    [SXD_TRAP_ID_IPBC] = "SXD_IPBC",
    [SXD_TRAP_ID_ETH_L3_RPF] = "SXD_L3_RPF",
    [SXD_TRAP_ID_ETH_L3_ASSERT] = "SXD_L3_ASSERT",
    [SXD_TRAP_ID_IP2ME] = "SXD_IP2ME",
    [SXD_TRAP_ID_RTR_INGRESS0] = "SXD_RTR_INGRESS0",
    [SXD_TRAP_ID_RTR_INGRESS1] = "SXD_RTR_INGRESS1",
    [SXD_TRAP_ID_RTR_INGRESS2] = "SXD_RTR_INGRESS2",
    [SXD_TRAP_ID_RTR_INGRESS3] = "SXD_RTR_INGRESS3",
    [SXD_TRAP_ID_RTR_EGRESS0] = "SXD_RTR_EGRESS0",
    [SXD_TRAP_ID_RTR_EGRESS1] = "SXD_RTR_EGRESS1",
    [SXD_TRAP_ID_RTR_EGRESS2] = "SXD_RTR_EGRESS2",
    [SXD_TRAP_ID_RTR_EGRESS3] = "SXD_RTR_EGRESS3",
    [SXD_TRAP_ID_HOST_MISS_IPV4] = "SXD_HOST_MISS_IPV4",
    [SXD_TRAP_ID_HOST_MISS_IPV6] = "SXD_HOST_MISS_IPV6",
    [SXD_TRAP_ID_BFD_IPV4] = "SXD_BFD_IPV4",
    [SXD_TRAP_ID_BFD_IPV6] = "SXD_BFD_IPV6",
    [SXD_TRAP_ID_SSH_IPV4] = "SXD_SSH_IPV4",
    [SXD_TRAP_ID_SSH_IPV6] = "SXD_SSH_IPV6",
    [SXD_TRAP_ID_PING_IPV4] = "SXD_PING_IPV4",
    [SXD_TRAP_ID_PING_IPV6] = "SXD_PING_IPV6",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV4] = "SXD_ROUTER_ALERT_IPV4",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV6] = "SXD_ROUTER_ALERT_IPV6",
    [SXD_TRAP_ID_IPV4_DHCP] = "SXD_IPV4_DHCP",
    [SXD_TRAP_ID_IPV4_SNMP] = "SXD_SNMP_IPV4",
    [SXD_TRAP_ID_IPV6_SNMP] = "SXD_SNMP_IPV6",
    [SXD_TRAP_ID_ROUTER_ARPBC] = "SXD_ROUTER_ARPBC",
    [SXD_TRAP_ID_ROUTER_ARPUC] = "SXD_ROUTER_ARPUC",
    [SXD_TRAP_ID_ROUTER_RARP_OPCODES] = "SXD_ROUTER_RARP",

    /* IPv6 L3 */
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_ADDRESS] = "SXD_IPV6_UNSPEC_ADDR",
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_SIP] = "SXD_IPV6_UNSPEC_SIP",
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_DIP] = "SXD_IPV6_UNSPEC_DIP",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_DST] = "SXD_IPV6_LINK_LOCAL_DST",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_SRC] = "SXD_IPV6_LINK_LOCAL_SRC",
    [SXD_TRAP_ID_IPV6_ALL_NODES_LINK] = "SXD_IPV6_ALL_NODES_LINK",
    [SXD_TRAP_ID_IPV6_OSPF] = "SXD_IPV6_OSPF",
    [SXD_TRAP_ID_IPV6_DHCP] = "SXD_IPV6_DHCP",

    [SXD_TRAP_ID_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    [SXD_TRAP_ID_IPV6_ALL_ROUTERS_LINK] = "SXD_IPV6_ALL_ROUTERS_LINK",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    /* IPv6 L2 */
    [SXD_TRAP_ID_IPV6_MLD_V1_V2] = "SXD_IPV6_MLD_V1_V2",
    [SXD_TRAP_ID_IPV6_MLD_V1_REPORT] = "SXD_IPV6_MLD_V1_REPORT",
    [SXD_TRAP_ID_IPV6_MLD_V1_DONE] = "SXD_IPV6_MLD_V1_DONE",
    [SXD_TRAP_ID_IPV6_MLD_V2_REPORT] = "SXD_IPV6_MLD_V2_REPORT",

    /* InfiniBand */
    [SXD_TRAP_ID_INFINIBAND_QP0] = "SXD_INFINIBAND_QP0",                         /**< IB QP0 */
    [SXD_TRAP_ID_INFINIBAND_QP1] = "SXD_INFINIBAND_QP1",                         /**< IB QP1 */
    [SXD_TRAP_ID_INFINIBAND_OTHER_QPS] = "SXD_INFINIBAND_OTHER_QPS",           /**< IB OTHERS */
    [SXD_TRAP_ID_INFINIBAND_EXTERNAL_SMA] = "SXD_INFINIBAND_EXTERNAL_SMA",      /**< IB External SMA */
    [SXD_TRAP_ID_INFINIBAND_IN_NV_ACCESS_REG] = "SXD_INFINIBAND_IN_NV_ACCESS_REG", /**< IB VS-MAD with ACCESS_REG with one of the NV Config registers */
    [SXD_TRAP_ID_INFINIBAND_IB_FMAD_RCV] = "SXD_INFINIBAND_IB_FMAD_RCV",     /**< IB VS-MAD with ACCESS_REG with one of Config registers */
    [SXD_TRAP_ID_INFINIBAND_RESET_CMD] = "SXD_INFINIBAND_RESET_CMD",       /**< IB RESET CMD */

    /* MPLS */
    [SXD_TRAP_ID_MPLS_ILM_MISS] = "SXD_MPLS_ILM_MISS",
    [SXD_TRAP_ID_MPLS_LDP] = "SXD_MPLS_LDP",
    [SXD_TRAP_ID_MPLS_LB_LSP_PING] = "SXD_LB_LSP_PING",
    [SXD_TRAP_ID_MPLS_ILM0] = "SXD_MPLS_ILM0",
    [SXD_TRAP_ID_MPLS_ILM1] = "SXD_MPLS_ILM1",
    [SXD_TRAP_ID_MPLS_NHLFE0] = "SXD_MPLS_NHLFE0",
    [SXD_TRAP_ID_MPLS_NHLFE1] = "SXD_MPLS_NHLFE1",

    /* BGP */
    [SXD_TRAP_ID_IPV4_BGP] = "SXD_IPV4_BGP",
    [SXD_TRAP_ID_IPV6_BGP] = "SXD_IPV6_BGP",

    /* SPAN */
    [SXD_TRAP_ID_MIRROR] = "SXD_MIRROR",
    [SXD_TRAP_ID_MIRROR_AGENT0] = "SXD_MIRROR_AGENT0",
    [SXD_TRAP_ID_MIRROR_AGENT1] = "SXD_MIRROR_AGENT1",
    [SXD_TRAP_ID_MIRROR_AGENT2] = "SXD_MIRROR_AGENT2",
    [SXD_TRAP_ID_MIRROR_AGENT3] = "SXD_MIRROR_AGENT3",
    [SXD_TRAP_ID_MIRROR_AGENT4] = "SXD_MIRROR_AGENT4",
    [SXD_TRAP_ID_MIRROR_AGENT5] = "SXD_MIRROR_AGENT5",
    [SXD_TRAP_ID_MIRROR_AGENT6] = "SXD_MIRROR_AGENT6",
    [SXD_TRAP_ID_MIRROR_AGENT7] = "SXD_MIRROR_AGENT7",

    /* Tunneling */
    [SXD_TRAP_ID_DECAP_ENCAP] = "SXD_DECAP_ENCAP",
    [SXD_TRAP_ID_IPIP_DECAP_ERROR] = "SXD_IPIP_DECAP_ERROR",
    [SXD_TRAP_ID_IPIP_ERROR] = "SXD_IPIP_ERROR",
    [SXD_TRAP_ID_NVE_DECAP_IGMP] = "SXD_NVE_DECAP_IGMP",
    [SXD_TRAP_ID_NVE_DECAP_ARP] = "SXD_NVE_DECAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_TAG_ERROR] = "SXD_NVE_DECAP_TAG_ERROR",
    [SXD_TRAP_ID_NVE_IPV4_DHCP] = "SXD_NVE_IPV4_DHCP",
    [SXD_TRAP_ID_NVE_IPV6_DHCP] = "SXD_NVE_IPV6_DHCP",
    [SXD_TRAP_ID_NVE_DECAP_FRAG_ERROR] = "SXD_NVE_DECAP_FRAG_ERROR",
    [SXD_TRAP_ID_NVE_ENCAP_ARP] = "SXD_NVE_ENCAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_ETH] = "SXD_NVE_DECAP_ETH",
    [SXD_TRAP_ID_NVE_DECAP_MLD] = "SXD_NVE_DECAP_MLD",

    /* Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET] = "SXD_DISCARD_ING_PACKET",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH] = "SXD_DISCARD_ING_SWITCH",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH] = "SXD_DISCARD_LOOKUP_SWITCH",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER] = "SXD_DISCARD_ING_ROUTER",
    [SXD_TRAP_ID_DISCARD_ING_LSR] = "SXD_DISCARD_ING_LSR",
    [SXD_TRAP_ID_DISCARD_ROUTER] = "SXD_DISCARD_ROUTER",
    [SXD_TRAP_ID_DISCARD_LSR] = "SXD_DISCARD_LSR",
    [SXD_TRAP_ID_DISCARD_DEC] = "SXD_DISCARD_DEC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH] = "SXD_DISCARD_OVERLAY_SWITCH",
    [SXD_TRAP_ID_DISCARD_ISOLATION] = "SXD_DISCARD_ISOLATION",
    [SXD_TRAP_ID_DISCARD_NON_ROUTED] = "SXD_DISCARD_NON_ROUTED",
    [SXD_TRAP_ID_DISCARD_EGR_LSR] = "SXD_DISCARD_EGR_LSR",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE] = "SXD_DISCARD_MC_SCOPE",
    [SXD_TRAP_ID_DISCARD_ROUTER2] = "SXD_DISCARD_ROUTER2",
    [SXD_TRAP_ID_DISCARD_ROUTER3] = "SXD_DISCARD_ROUTER3",
    [SXD_TRAP_ID_DISCARD_LSR2] = "SXD_DISCARD_LSR2",
    [SXD_TRAP_ID_DISCARD_LSR3] = "SXD_DISCARD_LSR3",

    /* Extended Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_MC] = "SXD_DISCARD_ING_PACKET_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_DMAC] = "SXD_DISCARD_ING_PACKET_SMAC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_RSV_MAC] = "SXD_DISCARD_ING_PACKET_RSV_MAC",

    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VTAG_ALLOW] = "SXD_DISCARD_ING_SWITCH_VTAG_ALLOW",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VLAN] = "SXD_DISCARD_ING_SWITCH_VLAN",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_STP] = "SXD_DISCARD_ING_SWITCH_STP",

    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_UC] = "SXD_DISCARD_LOOKUP_SWITCH_UC",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_MC_NULL] = "SXD_DISCARD_LOOKUP_SWITCH_MC_NULL",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_LB] = "SXD_DISCARD_LOOKUP_SWITCH_LB",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_NO_PORTS] = "SXD_DISCARD_LOOKUP_SWITCH_NO_PORTS",

    [SXD_TRAP_ID_DISCARD_ING_ROUTER_NO_HDR] = "SXD_DISCARD_ING_ROUTER_NO_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LB] = "SXD_DISCARD_ING_ROUTER_DIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_MC] = "SXD_DISCARD_ING_ROUTER_SIP_MC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_CLASS_E] = "SXD_DISCARD_ING_ROUTER_SIP_CLASS_E",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LB] = "SXD_DISCARD_ING_ROUTER_SIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_UNSP] = "SXD_DISCARD_ING_ROUTER_SIP_UNSP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_IP_HDR] = "SXD_DISCARD_ING_ROUTER_IP_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_DIP] = "SXD_DISCARD_ING_ROUTER_SIP_DIP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_BC] = "SXD_DISCARD_ING_ROUTER_SIP_BC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LOCAL_NET] = "SXD_DISCARD_ING_ROUTER_DIP_LOCAL_NET",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_DIP_LINK_LOCAL",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_SIP_LINK_LOCAL",

    [SXD_TRAP_ID_DISCARD_ING_LSR_NO_LABEL] = "SXD_DISCARD_ING_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_ING_LSR_UC_ET] = "SXD_DISCARD_ING_LSR_UC_ET",
    [SXD_TRAP_ID_DISCARD_ING_LSR_MC_DMAC] = "SXD_DISCARD_ING_LSR_MC_DMAC",

    [SXD_TRAP_ID_DISCARD_ROUTER_IRIF_EN] = "SXD_DISCARD_ROUTER_IRIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_EN] = "SXD_DISCARD_ROUTER_ERIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_FWD] = "SXD_DISCARD_ROUTER_ERIF_FWD",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM4] = "SXD_DISCARD_ROUTER_LPM4",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM6] = "SXD_DISCARD_ROUTER_LPM6",

    [SXD_TRAP_ID_DISCARD_LSR_MIN_LABEL] = "SXD_DISCARD_LSR_MIN_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_MAX_LABEL] = "SXD_DISCARD_LSR_MAX_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_LB] = "SXD_DISCARD_LSR_LB",

    [SXD_TRAP_ID_DISCARD_DEC_PKT] = "SXD_DISCARD_DEC_PKT",
    [SXD_TRAP_ID_DISCARD_DEC_DIS] = "SXD_DISCARD_DEC_DIS",

    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_MC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_DMAC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_DMAC",

    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_LABEL] = "SXD_DISCARD_EGR_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_IP] = "SXD_DISCARD_EGR_LSR_NO_IP",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_PHP_NO_IP] = "SXD_DISCARD_EGR_LSR_PHP_NO_IP",

    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_0] = "SXD_DISCARD_MC_SCOPE_IPV6_0",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_1] = "SXD_DISCARD_MC_SCOPE_IPV6_1",

    /* SWITCHX SDK EVENTS */
    [SXD_TRAP_ID_SIGNAL] = "SXD_SW_EV_SIGNAL",             /**< signal trap for SDK internal use */
    [SXD_TRAP_ID_OBJECT_DELETED_EVENT] = "SXD_OBJECT_DELETED_EVENT",
    [SXD_TRAP_ID_PORT_ADDED] = "SXD_PORT_ADDED",
    [SXD_TRAP_ID_PORT_DELETED] = "SXD_PORT_DELETED",
    [SXD_TRAP_ID_PORT_ADDED_TO_LAG] = "SXD_PORT_ADDED_TO_LAG",
    [SXD_TRAP_ID_PORT_REMOVED_FROM_LAG] = "SXD_PORT_REMOVED_FROM_LAG",
    [SXD_TRAP_ID_NEW_DEVICE_ADD] = "SXD_SW_EV_NEW_DEVICE_ADD",                  /**< device add event */
    [SXD_TRAP_ID_MAC_LEARNING_EVENT] = "SXD_SW_EV_MAC_LEARNING_EVENT",              /**< mac learning event */
    [SXD_TRAP_ID_MAC_AGING_EVENT] = "SXD_SW_EV_MAC_AGING_EVENT",                 /**< mac aging event */
    [SXD_TRAP_ID_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NEED_TO_RESOLVE_ARP",             /**< need to resolve ARP  */
    [SXD_TRAP_ID_NO_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NO_NEED_TO_RESOLVE_ARP",          /**< no need to resolve ARP  */
    [SXD_TRAP_ID_FDB_EVENT] = "SXD_SW_EV_FDB_EVENT",                       /**< FDB event */
    [SXD_TRAP_ID_RM_SDK_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_SDK_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_RM_HW_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_HW_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_FDB_SRC_MISS] = "SXD_SW_EV_FDB_SRC_MISS",                    /**< FDB SRC MISS trap */
    [SXD_TRAP_ID_ROUTER_NEIGH_ACTIVITY] = "SXD_SW_EV_ROUTER_NEIGH_ACTIVITY",
    [SXD_TRAP_ID_ASYNC_API_COMPLETE_EVENT] = "SXD_SW_EV_ASYNC_API_COMPLETE_EVENT",
    [SXD_TRAP_ID_ROUTER_MC_ACTIVITY] = "SXD_SW_EV_ROUTER_MC_ACTIVITY",              /**< router mc activity */
    [SXD_TRAP_ID_FDB_IP_ADDR_ACTIVITY] = "SXD_SW_EV_FDB_IP_ADDR_ACTIVITY",            /**< fdb ip addr activity */
    [SXD_TRAP_ID_TRANSACTION_ERROR] = "SXD_SW_EV_TRANSACTION_ERROR",               /**< error in transaction mode */
    [SXD_TRAP_ID_BFD_TIMEOUT_EVENT] = "SXD_SW_EV_BFD_TIMEOUT_EVENT",
    [SXD_TRAP_ID_BFD_PACKET_EVENT] = "SXD_SW_EV_BFD_PACKET_EVENT",
    [SXD_TRAP_ID_SDK_HEALTH_EVENT] = "SXD_SW_SDK_HEALTH_EVENT",


    /* User defined trap ID */
    [SXD_TRAP_ID_IP2ME_CUSTOM0] = "SXD_IP2ME_CUSTOM0",
    [SXD_TRAP_ID_IP2ME_CUSTOM1] = "SXD_IP2ME_CUSTOM1",

    [SXD_TRAP_ID_CONFT_SWITCH0] = "SXD_TRAP_ID_CONFT_SWITCH0",
    [SXD_TRAP_ID_CONFT_SWITCH1] = "SXD_TRAP_ID_CONFT_SWITCH1",
    [SXD_TRAP_ID_CONFT_SWITCH2] = "SXD_TRAP_ID_CONFT_SWITCH2",
    [SXD_TRAP_ID_CONFT_SWITCH3] = "SXD_TRAP_ID_CONFT_SWITCH3",

    [SXD_TRAP_ID_CONFT_ROUTER0] = "SXD_TRAP_ID_CONFT_ROUTER0",
    [SXD_TRAP_ID_CONFT_ROUTER1] = "SXD_TRAP_ID_CONFT_ROUTER1",
    [SXD_TRAP_ID_CONFT_ROUTER2] = "SXD_TRAP_ID_CONFT_ROUTER2",
    [SXD_TRAP_ID_CONFT_ROUTER3] = "SXD_TRAP_ID_CONFT_ROUTER3",

    [SXD_TRAP_ID_CONFT_SWITCH_ENC0] = "SXD_TRAP_ID_CONFT_SWITCH_ENC0",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC1] = "SXD_TRAP_ID_CONFT_SWITCH_ENC1",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC2] = "SXD_TRAP_ID_CONFT_SWITCH_ENC2",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC3] = "SXD_TRAP_ID_CONFT_SWITCH_ENC3",

    [SXD_TRAP_ID_CONFT_SWITCH_DEC0] = "SXD_TRAP_ID_CONFT_SWITCH_DEC0",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC1] = "SXD_TRAP_ID_CONFT_SWITCH_DEC1",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC2] = "SXD_TRAP_ID_CONFT_SWITCH_DEC2",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC3] = "SXD_TRAP_ID_CONFT_SWITCH_DEC3",

    [SXD_TRAP_ID_MAX + 1] = "SXD_UNKNOWN",                               /**< MAXIMUM TRAP ID */
};

#define SXD_TRAP_ID_STR_SIZE (sizeof(sxd_trap_id_str_s) / sizeof(sxd_trap_id_str_s[0]))

/************************************************
 *  Function implementations
 ***********************************************/
const char * trap_id_str(u16 trap_id)
{
    if (trap_id == NUM_HW_SYNDROMES) {
        return TRAP_ANY_STR;
    } else if ((trap_id >= SXD_TRAP_ID_ACL_MIN) && (trap_id <= SXD_TRAP_ID_ACL_MAX)) {
        return TRAP_ACL_OR_ROUTER_STR;
    } else {
        return (trap_id < SXD_TRAP_ID_STR_SIZE && sxd_trap_id_str_s[trap_id] ?
                sxd_trap_id_str_s[trap_id] : TRAP_UNKNOWN_STR);
    }
}

static void print_header(struct seq_file *m, const char* header)
{
    seq_printf(m,
               "\n========================================================================================================================\n");
    seq_printf(m, "%s", header);
    seq_printf(m,
               "\n========================================================================================================================\n\n");
}

#define print_table_header(seqfile, fmt, args ...)                                                                                                \
    do {                                                                                                                                          \
        seq_printf((seqfile), fmt "\n", ## args);                                                                                                 \
        seq_printf((seqfile),                                                                                                                     \
                   "------------------------------------------------------------------------------------------------------------------------\n"); \
    } while (0)

#define print_empty_line(seqfile)    \
    do {                             \
        seq_printf((seqfile), "\n"); \
    } while (0)

#define print_separate_line(seqfile)                                                                                                              \
    do {                                                                                                                                          \
        seq_printf((seqfile),                                                                                                                     \
                   "........................................................................................................................\n"); \
    } while (0)


static inline int SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(u64 *arr, u32 num)
{
    int idx = (num) / 64;
    u64 bit = (1ULL << ((num) % 64));

    return ((arr)[idx] & (bit));
}

static inline int SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(u64 *arr, u32 size)
{
    int i = 0;

    for (i = 0; i < size; i++) {
        if (arr[i] != 0) {
            return 0;
        }
    }
    return 1;
}

static void print_listener(struct seq_file *m, u16 synd, struct listener_entry           *listener)
{
    static char                               handler_name[KSYM_SYMBOL_LEN] = "";
    static char                               uc_name[DBG_DUMP_BUFF_SIZE] = "";
    static char                               type_name[DBG_DUMP_BUFF_SIZE] = "";
    static char                               type_crit[DBG_DUMP_BUFF_SIZE] = "";
    static char                               reg_key_name[DBG_DUMP_BUFF_SIZE] = "";
    const struct sx_psample_listener_context *psample_ctx;
    char                                     *end;

    memset(handler_name, 0, sizeof(handler_name));
    memset(uc_name, 0, sizeof(uc_name));
    memset(type_name, 0, sizeof(type_name));
    memset(type_crit, 0, sizeof(type_crit));
    memset(reg_key_name, 0, sizeof(reg_key_name));

    sprint_symbol(handler_name, (unsigned long)listener->handler);
    end = strchr(handler_name, '+');
    if (end) {
        *end = '\0';
    }

    if (strstr(handler_name, "sx_netdev_handle_pude_event")) {
        strcpy(uc_name, "PUDE");
    } else if (strstr(handler_name, "sx_ib_handle_rx_pkt")
               || strstr(handler_name, "sx_ib_rpa_handle_rx_pkt")
               || strstr(handler_name, "sx_ib_tca_handle_rx_pkt")
               || strstr(handler_name, "sx_netdev_handle_global_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_cq_handler")) {
        strcpy(uc_name, "FD");
    } else if (strstr(handler_name, "sx_netdev_handle_rx_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_log_port_rx_pkt")) {
        strcpy(uc_name, "LOG_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_phy_port_rx_pkt")) {
        strcpy(uc_name, "PHY_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_l2_tunnel_handler")) {
        strcpy(uc_name, "L2_TUNNEL");
    } else if (strstr(handler_name, "psample")) {
        psample_ctx = (struct sx_psample_listener_context*)listener->context;
        snprintf(uc_name, sizeof(uc_name) - 1, "PSAMPLE [g=%u,rc=%u]",
                 psample_ctx->group_num, psample_ctx->refcnt);
    } else {
        strncpy(uc_name, handler_name, sizeof(uc_name) - 1);
    }

    switch (listener->listener_type) {
    case L2_TYPE_DONT_CARE:
        strcpy(type_name, "Don't Care");
        if (listener->critireas.dont_care.sysport != SYSPORT_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", sysport %d", listener->critireas.dont_care.sysport);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_IB:
        strcpy(type_name, "IB");
        if (listener->critireas.ib.qpn != QPN_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", qpn %d", listener->critireas.ib.qpn);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_ETH:
        strcpy(type_name, "ETH");
        if (listener->critireas.eth.ethtype != ETHTYPE_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", ethtype 0x%x", listener->critireas.eth.ethtype);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.dmac != DMAC_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", dmac 0x%llx", listener->critireas.eth.dmac);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.emad_tid != TID_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", emad_tid 0x%x", listener->critireas.eth.emad_tid);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_rp != IS_RP_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_rp %d", listener->critireas.eth.from_rp);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_bridge != IS_BRIDGE_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_bridge %d", listener->critireas.eth.from_bridge);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_FC:
        strcpy(type_name, "FC");
        break;

    default:
        strcpy(type_name, "NA");
    }
    seq_printf(m, "%-30s| %-8d| %-20s| %-25s| %-15llu| %u\n",
               trap_id_str(synd),
               synd,
               uc_name,
               type_name,
               listener->rx_pkts,
               listener->is_default);
}


static int __trap_reg_dump(struct seq_file *m, void *v)
{
    struct listener_entry *listener;
    struct list_head      *pos;
    unsigned long          flags;
    u16                    synd = 0;

    print_header(m, "Trap Registration");

    print_table_header(m, "%-30s| %-8s| %-20s| %-25s| %-15s| %s",
                       "Trap Name", "Trap ID", "User Channel", "Type", "RX packets", "Is default");

    spin_lock_irqsave(&sx_glb.listeners_lock, flags);
    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        if (!list_empty(&sx_glb.listeners_rf_db[synd].list)) {
            list_for_each(pos, &sx_glb.listeners_rf_db[synd].list) {
                listener = list_entry(pos, struct listener_entry, list);
                print_listener(m, synd, listener);
            }
        }
    }

    spin_unlock_irqrestore(&sx_glb.listeners_lock, flags);

    print_empty_line(m);
    return 0;
}

static int __trap_filter_register_dump(struct seq_file *m, void *v)
{
    struct listener_entry *listener;
    struct list_head      *pos;
    unsigned long          flags;
    u16                    synd = 0;
    int                    i = 0;

    print_header(m, "Trap Registrations and Filters");

    spin_lock_irqsave(&sx_glb.listeners_lock, flags);
    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        if (!list_empty(&sx_glb.listeners_rf_db[synd].list)) {
            list_for_each(pos, &sx_glb.listeners_rf_db[synd].list) {
                print_table_header(m, "%-30s| %-8s| %-20s| %-25s| %-15s| %s",
                                   "Trap Name", "Trap ID", "User Channel", "Type", "RX packets", "Is default");
                listener = list_entry(pos, struct listener_entry, list);
                print_listener(m, synd, listener);
                print_empty_line(m);

                print_table_header(m, "%s", "listener Reg/Filter info:");

                seq_printf(m, "%s", "Global Filter: ");
                listener->listener_register_filter.is_global_filter ? seq_printf(m, "%s", "True") : seq_printf(m,
                                                                                                               "%s",
                                                                                                               "False");

                seq_printf(m, "%s", "\nPorts Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.ports_filters,
                                                         FROM_BITS_TO_U64(MAX_PHYPORT_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 1; i < MAX_PHYPORT_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.ports_filters,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }

                seq_printf(m, "%s", "\nVlans Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.vlans_filters,
                                                         FROM_BITS_TO_U64(SXD_MAX_VLAN_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 0; i < SXD_MAX_VLAN_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.vlans_filters,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }

                seq_printf(m, "%s", "\nLags Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.lags_filters,
                                                         FROM_BITS_TO_U64(MAX_LAG_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_LAG_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.lags_filters,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }

                seq_printf(m, "%s", "\nGlobal Register: ");
                listener->listener_register_filter.is_global_register ? seq_printf(m, "%s", "True") : seq_printf(m,
                                                                                                                 "%s",
                                                                                                                 "False");

                seq_printf(m, "%s", "\nPorts Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.ports_registers,
                                                         FROM_BITS_TO_U64(MAX_PHYPORT_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.ports_registers,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }

                seq_printf(m, "%s", "\nVlans Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.vlans_registers,
                                                         FROM_BITS_TO_U64(SXD_MAX_VLAN_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 0; i < SXD_MAX_VLAN_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.vlans_registers,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }

                seq_printf(m, "%s", "\nLags Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.lags_registers,
                                                         FROM_BITS_TO_U64(MAX_LAG_NUM + 1))) {
                    seq_printf(m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_LAG_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.lags_registers,
                                                                   i)) {
                            seq_printf(m, " %u|", i);
                        }
                    }
                }
                print_empty_line(m);
                print_empty_line(m);
                print_separate_line(m);
            }
        }
    }

    spin_unlock_irqrestore(&sx_glb.listeners_lock, flags);

    print_empty_line(m);
    return 0;
}

static int __host_ifc_stats_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    int             pkt_type, synd, rdq;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "host-ifc stats dump");

    print_table_header(m, "%-30s   %-15s",
                       "RX-type", "RX-packets");

    for (pkt_type = 0; pkt_type < PKT_TYPE_NUM; pkt_type++) {
        if (dev->stats.rx_by_pkt_type[0][pkt_type]) {
            seq_printf(m, "%-30s   %-15llu\n",
                       sx_cqe_packet_type_str[pkt_type],
                       dev->stats.rx_by_pkt_type[0][pkt_type]);
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-30s   %-15s   %-15s",
                       "TX-type", "TX-packets", "TX-bytes");

    for (pkt_type = 0; pkt_type < PKT_TYPE_NUM; pkt_type++) {
        if (dev->stats.tx_by_pkt_type[0][pkt_type]) {
            seq_printf(m, "%-30s   %-15llu   %-15llu\n",
                       ku_pkt_type_str[pkt_type],
                       dev->stats.tx_by_pkt_type[0][pkt_type],
                       dev->stats.tx_by_pkt_type_bytes[0][pkt_type]);
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-4s   %-15s   %-15s",
                       "trap", "RX-packets", "RX-bytes");

    for (synd = 0; synd < NUM_HW_SYNDROMES; synd++) {
        if (dev->stats.rx_by_synd[0][synd]) {
            seq_printf(m, "%-4d   %-15llu   %-15llu\n",
                       synd,
                       dev->stats.rx_by_synd[0][synd],
                       dev->stats.rx_by_synd_bytes[0][synd]);
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-3s   %-15s   %-15s",
                       "RDQ", "RX-packets", "RX-bytes");

    for (rdq = 0; rdq < NUMBER_OF_RDQS; rdq++) {
        if (dev->stats.rx_by_rdq[0][rdq]) {
            seq_printf(m, "%-3d   %-15llu   %-15llu\n",
                       rdq,
                       dev->stats.rx_by_rdq[0][rdq],
                       dev->stats.rx_by_rdq_bytes[0][rdq]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __unconsumed_pkt_dump(struct seq_file *m, void *v)
{
    u16 synd = 0;
    u64 total_cnt = 0;
    int pkt_ind = 0;

    print_header(m, "Unconsumed packets");

    print_table_header(m, "%-40s|%-8s| %s",
                       "Trap Name", "Trap ID", "Total Unconsumed packets");

    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        total_cnt = 0;
        for (pkt_ind = 0; pkt_ind < PKT_TYPE_NUM; pkt_ind++) {
            total_cnt = total_cnt + sx_glb.stats.rx_unconsumed_by_synd[synd][pkt_ind];
        }
        if (total_cnt > 0) {
            seq_printf(m, "%-40s|%-8d| %llu\n", trap_id_str(synd), synd, total_cnt);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __cq_dump(struct seq_file *m, void *v)
{
    u8                           cqn = 0;
    unsigned long                flags;
    struct sx_cq_table          *cq_table;
    long                         now = jiffies;
    int                          last_time_armed, last_time_event;
    struct sx_dev               *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct cpu_traffic_priority *cpu_traffic_prio;
    struct sx_priv              *priv;
    u32                          diff;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);
    if (!priv) {
        return 0;
    }

    cq_table = &priv->cq_table;
    if (!cq_table) {
        return 0;
    }

    cpu_traffic_prio = &cq_table->cpu_traffic_prio;

    print_header(m, "CQ dump");

    if (atomic_read(&cpu_traffic_prio->high_prio_cq_in_load) == 1) {
        seq_printf(m, "*** CPU is under storm traffic! ***\n");
    }

    print_table_header(m,
                       "%-14s | %-4s | %-8s | %-8s | %-5s | %-8s | %-6s | %-7s | %-10s | %-11s",
                       "CQ #",
                       "prio",
                       "cons_idx",
                       "diff",
                       "nent",
                       "cons_mod",
                       "refcnt",
                       "CQE-ver",
                       "arm (sec) ",
                       "event (sec)");

    spin_lock_irqsave(&cq_table->lock, flags);
    for (cqn = 0; cqn < dev->dev_cap.max_num_cqs; cqn++) {
        if (cqn == NUMBER_OF_SDQS) {
            print_separate_line(m);
        }

        if (cq_table->cq[cqn] != NULL) {
            last_time_armed = (priv->cq_last_time_armed[cqn] != 0) ?
                              (jiffies_to_msecs(now - priv->cq_last_time_armed[cqn]) / 1000) : 0;

            last_time_event = (priv->cq_last_time_event[cqn] != 0) ?
                              (jiffies_to_msecs(now - priv->cq_last_time_event[cqn]) / 1000) : 0;

            if (cq_table->cq[cqn]->cons_index > cq_table->cq[cqn]->cons_index_snapshot) {
                diff = cq_table->cq[cqn]->cons_index - cq_table->cq[cqn]->cons_index_snapshot;
            } else {
                diff = 0xffffffff - cq_table->cq[cqn]->cons_index_snapshot + 1 + cq_table->cq[cqn]->cons_index;
            }

            cq_table->cq[cqn]->cons_index_snapshot = cq_table->cq[cqn]->cons_index;

            seq_printf(m, "CQ %02u (%s %02u) | %-4s | %-8u | %-8u | %-5u | %-8u | %-6u | %-7u | %-10u | %-10u\n",
                       cqn, ((cqn < NUMBER_OF_SDQS) ? "SDQ" : "RDQ"),
                       ((cqn < NUMBER_OF_SDQS) ? cqn : cqn - NUMBER_OF_SDQS),
                       (sx_bitmap_test(&cpu_traffic_prio->high_prio_cq_bitmap, cqn) ? "high" : "low"),
                       cq_table->cq[cqn]->cons_index,
                       diff,
                       cq_table->cq[cqn]->nent,
                       (cq_table->cq[cqn]->cons_index & (cq_table->cq[cqn]->nent - 1)),
                       atomic_read(&cq_table->cq[cqn]->refcount),
                       cq_table->cq[cqn]->cqe_version,
                       jiffies_to_msecs(now - priv->cq_last_time_armed[cqn]) / 1000,
                       jiffies_to_msecs(now - priv->cq_last_time_event[cqn]) / 1000);
        }
    }
    spin_unlock_irqrestore(&cq_table->lock, flags);

    print_empty_line(m);
    return 0;
}


static struct proc_info * __name_to_info(const char *name)
{
    struct proc_info *iter;

    if (!name) {
        return NULL;
    }

    list_for_each_entry(iter, &__proc_list, list) {
        if (strcmp(name, iter->name) == 0) {
            return iter;
        }
    }

    return NULL;
}


static int __ber_monitor_dump(struct seq_file *m, void *v)
{
    u8             i = 0;
    unsigned long  flags;
    const char   * state_2_str[] = {"Disable", "Normal", "Warning", "Alarm"};
    const char   * bitmask_2_str[] = {"Disable", "N", "W", "NW", "A", "AN", "AW", "ANW"};
    struct sx_dev *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return 0;
    }

    print_header(m, "BER monitor dump");

    print_table_header(m, "%-11s| %-11s| %-11s",
                       "local_port", "bitmask", "state");

    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
        if (sx_priv(dev)->port_ber_monitor_bitmask[i] != 0) {
            if ((sx_priv(dev)->port_ber_monitor_bitmask[i] < 8)
                && (sx_priv(dev)->port_ber_monitor_state[i] < 4)) {
                seq_printf(m, "%-11d| %-11s| %-11s\n",
                           i,
                           bitmask_2_str[sx_priv(dev)->port_ber_monitor_bitmask[i]],
                           state_2_str[sx_priv(dev)->port_ber_monitor_state[i]]);
            } else {
                seq_printf(m, "%-11d| %-11d| %-11d\n",
                           i,
                           sx_priv(dev)->port_ber_monitor_bitmask[i],
                           sx_priv(dev)->port_ber_monitor_state[i]);
            }
        }
    }
    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    print_empty_line(m);
    return 0;
}


static int __tele_thrs_dump(struct seq_file *m, void *v)
{
    u8             i = 0;
    unsigned long  flags;
    struct sx_dev *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return 0;
    }

    print_header(m, "TELE threshold dump");

    print_table_header(m, "%-11s| %-11s| %s", "local_port", "state", "tc_pg_vec");
    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
        if (sx_priv(dev)->tele_thrs_state[i][TELE_DIR_ING_EGRESS_E]) {
            seq_printf(m, "%-11u| %-11u| [tc] %llx\n",
                       i,
                       sx_priv(dev)->tele_thrs_state[i][TELE_DIR_ING_EGRESS_E],
                       sx_priv(dev)->tele_thrs_tc_vec[i][TELE_DIR_ING_EGRESS_E]);
        }
        if (sx_priv(dev)->tele_thrs_state[i][TELE_DIR_ING_INGRESS_E]) {
            seq_printf(m, "%-11u| %-11u| [pg] %llx\n",
                       i,
                       sx_priv(dev)->tele_thrs_state[i][TELE_DIR_ING_INGRESS_E],
                       sx_priv(dev)->tele_thrs_tc_vec[i][TELE_DIR_ING_INGRESS_E]);
        }
    }
    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    print_empty_line(m);
    return 0;
}


static void __monitor_rdq_dump_one(struct seq_file *m, struct sx_dev *dev, int rdq_n)
{
    struct sx_priv     *priv = sx_priv(dev);
    struct sx_dq_table *rdq_table = &priv->rdq_table;
    struct sx_dq       *rdq;

    if (rdq_table == NULL) {
        seq_printf(m, "rdq table is empty\n");
        return;
    }

    if (rdq_n > (dev->dev_cap.max_num_rdqs - 1)) {
        seq_printf(m, "rdq_n %d is out of range [0..%d]\n",
                   rdq_n, dev->dev_cap.max_num_rdqs);
        return;
    }


    if (!rdq_table->dq[rdq_n]) {
        return;
    }

    rdq = rdq_table->dq[rdq_n];

    if (!rdq->is_monitor) {
        return;
    }

    seq_printf(m, "rdq %d data:  is_mon:%d, rx_cnt:%u, rx_start:%u, cpu_tc:%d \n",
               rdq_n,
               rdq->is_monitor,                  /* rdq is cyclic monitor rdq. non valid for sdq */
               rdq->mon_rx_count,
               rdq->mon_rx_start,
               rdq->cpu_tclass);
}


static int __monitor_rdq_dump(struct seq_file *m, void *v)
{
    int                 rdq_n;
    struct sx_priv     *priv = NULL;
    struct sx_dq_table *rdq_table = NULL;
    struct sx_dev      *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);
    rdq_table = &priv->rdq_table;
    print_header(m, "Monitor RDQ dump");

    for (rdq_n = 0; rdq_n < dev->dev_cap.max_num_rdqs; rdq_n++) {
        __monitor_rdq_dump_one(m, dev, rdq_n);
    }

    print_empty_line(m);
    return 0;
}


static int __fid_to_hwfid_dump(struct seq_file *m, void *v)
{
    u16             i = 0;
    u16             fid = 0;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    unsigned long   flags;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "FID to HW_FID mapping dump");

    print_table_header(m, "%-7s| %-7s| %-7s", "#", "FID", "HW_FID");

    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    i = 0;
    for (fid = 0; fid < MAX_FIDS_NUM; fid++) {
        if (priv->fid_to_hwfid[fid] != INVALID_HW_FID_ID) {
            i++;
            seq_printf(m, "%-7u| %-7u| %-7u\n",
                       i,
                       fid,
                       priv->fid_to_hwfid[fid]);
        }
    }

    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    print_empty_line(m);
    return 0;
}


static int __rif_to_hwfid_dump(struct seq_file *m, void *v)
{
    u16             i = 0;
    u16             rif_id = 0;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    unsigned long   flags;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "RIF to HW_FID mapping dump");

    print_table_header(m, "%-7s| %-7s| %-7s", "#", "RIF", "HW_FID");

    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    i = 0;
    for (rif_id = 0; rif_id < MAX_RIFS_NUM; rif_id++) {
        if (priv->rif_id_to_hwfid[rif_id] != INVALID_HW_FID_ID) {
            i++;
            seq_printf(m, "%-7u| %-7u| %-7u\n",
                       i,
                       rif_id,
                       priv->fid_to_hwfid[rif_id]);
        }
    }

    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    print_empty_line(m);
    return 0;
}


static int __sdq_completion_dump(struct seq_file *m, void *v)
{
    u16             sdqn = 0;
    struct sx_dq   *sdq = NULL;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "SDQ completion dump");

    print_table_header(m, "%-5s   %-15s   %-15s   %-15s   %-15s   %-15s",
                       "SDQ", "Sent", "Removed", "Recv Comp", "Not Recv Comp", "Late Comp");

    for (sdqn = 0; sdqn < dev->dev_cap.max_num_sdqs; sdqn++) {
        sdq = priv->sdq_table.dq[sdqn];
        if (sdq) {
            seq_printf(m, "%-5u   %-15llu   %-15llu   %-15llu   %-15llu   %-15llu\n",
                       sdqn,
                       (u64)atomic64_read(&sdq->pkts_sent_to_sdq),
                       (u64)atomic64_read(&sdq->pkts_removed_from_sdq),
                       (u64)atomic64_read(&sdq->pkts_recv_completion),
                       (u64)atomic64_read(&sdq->pkts_no_rev_completion),
                       (u64)atomic64_read(&sdq->pkts_late_completion));
        }
    }

    print_empty_line(m);
    return 0;
}


#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
static int __rdq_to_filter_ebpf_prog_dump(struct seq_file *m, void *v)
{
    u16             i = 0;
    u16             rdq = 0;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    unsigned long   flags;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "RDQ to filter eBPF program mapping dump");

    print_table_header(m, "%-7s| %-7s| %-20s", "#", "RDQ", "Filter eBPF program");

    spin_lock_irqsave(&sx_priv(dev)->rdq_table.lock, flags);

    i = 0;
    for (rdq = 0; rdq < (NUMBER_OF_RDQS); rdq++) {
        if (priv->filter_ebpf_progs[rdq] != NULL) {
            i++;
            seq_printf(m, "%-7u| %-7u| %-20p\n",
                       i,
                       rdq,
                       priv->filter_ebpf_progs[rdq]);
        }
    }

    spin_unlock_irqrestore(&sx_priv(dev)->rdq_table.lock, flags);

    print_empty_line(m);
    return 0;
}
#endif


static int __sys_to_local_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "system-port to local-port dump");

    print_table_header(m, "%-7s   %-5s   %-4s",
                       "system", "local", "PVID");

    for (i = 0; i < MAX_SYSPORT_NUM; i++) {
        if (priv->system_to_local_db[i] != 0) {
            seq_printf(m, "0x%-5x   %-5d   %-4d\n",
                       i, priv->system_to_local_db[i], priv->pvid_sysport_db[i]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __local_to_sys_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "local-port to system-port dump");

    print_table_header(m, "%-5s   %-7s   %-4s",
                       "local", "system", "PVID");

    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
        if (priv->local_to_system_db[i] != 0) {
            seq_printf(m, "%-5d   0x%-5x   %-4d\n",
                       i, priv->local_to_system_db[i], priv->pvid_sysport_db[priv->local_to_system_db[i]]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __lag_to_pvid_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "LAG to PVID dump");

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-6s   %-4s",
                       "LAG ID", "PVID");

    for (i = 0; i < lag_max; i++) {
        if (priv->pvid_lag_db[i] != 0) {
            seq_printf(m, "%-6d   %-4d\n",
                       i, priv->pvid_lag_db[i]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __lag_member_to_local_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0;
    u8              is_printed;
    int             i, j;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "LAG member to local dump");

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-6s   %-10s   %-5s",
                       "LAG ID", "LAG-member", "local");

    for (i = 0; i < lag_max; i++) { /* lag id */
        is_printed = 0;

        for (j = 0; j < lag_member_max; j++) { /* lag member id */
            if (priv->lag_member_to_local_db[i][j] != 0) {
                if (!is_printed) {
                    seq_printf(m, "%-6d   %-10d   %-5d\n",
                               i, j, priv->lag_member_to_local_db[i][j]);
                } else {
                    seq_printf(m, "%-6s   %-10d   %-5d\n",
                               "", j, priv->lag_member_to_local_db[i][j]);
                    is_printed = 1;
                }
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __router_port_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0, phy_port_max = 0;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "router port dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    for (i = 0; i < phy_port_max; i++) { /* system port */
        if (priv->local_is_rp[i] != 0) {
            seq_printf(m, "local: %d\n", i);
        }
    }

    print_empty_line(m);

    for (i = 0; i < lag_max; i++) { /* LAG ID */
        if (priv->lag_is_rp[i] != 0) {
            seq_printf(m, "LAG: %d\n", i);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __local_to_swid_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        phy_port_max = 0;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "local to swid dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    print_table_header(m, "%-5s   %-4s",
                       "local", "swid");

    for (i = 0; i < (phy_port_max + 1); i++) { /* system port */
        seq_printf(m, "%-5d   %-4d\n",
                   i, priv->local_to_swid_db[i]);
    }

    print_empty_line(m);
    return 0;
}


static int __truncate_size_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "truncate size dump");

    print_table_header(m, "%-3s   %-13s",
                       "RDQ", "truncate-size");

    for (i = 0; i < NUMBER_OF_RDQS; i++) { /* rdq */
        if (priv->truncate_size_db[i] != 0) {
            seq_printf(m, "%-3d   %-13d\n",
                       i, priv->truncate_size_db[i]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __trap_filter_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    u8              printed;
    int             i, j;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "trap filter dump");

    print_table_header(m, "%-40s   %-7s   %-7s",
                       "trap-name", "trap-id", "sysport");

    for (i = 0; i < NUM_HW_SYNDROMES; i++) { /* trap id */
        printed = 0;

        for (j = 0; j < MAX_SYSTEM_PORTS_IN_FILTER; j++) { /* system port */
            if (priv->sysport_filter_db[i][j] != 0) {
                if (!printed) {
                    seq_printf(m, "%-40s   %-7d   0x%-5x\n",
                               trap_id_str(i),
                               i,
                               priv->sysport_filter_db[i][j]);
                    printed = 1;
                } else {
                    seq_printf(m, "%-40s   %-7s   0x%-5x\n",
                               "",
                               "",
                               priv->sysport_filter_db[i][j]);
                }
            }
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-40s   %-7s   %-6s",
                       "trap-name", "trap-id", "LAG ID");

    for (i = 0; i < NUM_HW_SYNDROMES; i++) { /* trap id */
        printed = 0;

        for (j = 0; j < MAX_LAG_PORTS_IN_FILTER; j++) { /* system port */
            if (priv->lag_filter_db[i][j] != LAG_ID_INVALID) {
                if (!printed) {
                    seq_printf(m, "%-40s   %-7d   %-6d\n",
                               trap_id_str(i),
                               i,
                               priv->lag_filter_db[i][j]);
                    printed = 1;
                } else {
                    seq_printf(m, "%-40s   %-7s   %-6d\n",
                               "",
                               "",
                               priv->lag_filter_db[i][j]);
                }
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __prio_to_tc_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0, phy_port_max = 0;
    int             i, j;
    u8              is_printed;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "prio to tc dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-7s   %-4s   %-2s",
                       "sysport", "prio", "tc");

    for (i = 0; i < (phy_port_max + 1); i++) { /* system port */
        is_printed = 0;

        for (j = 0; j < (MAX_PRIO_NUM + 1); j++) { /* prio */
            if (priv->port_prio2tc[i][j]) {
                if (!is_printed) {
                    seq_printf(m, "0x%-5x   %-4d   %-2d\n",
                               i,
                               j,
                               priv->port_prio2tc[i][j]);
                    is_printed = 1;
                } else {
                    seq_printf(m, "%-7s   %-4d   %-2d\n",
                               "",
                               j,
                               priv->port_prio2tc[i][j]);
                }
            }
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-6s   %-4s   %-2s",
                       "LAG ID", "prio", "tc");

    for (i = 0; i < (lag_max + 1); i++) { /* LAG ID */
        is_printed = 0;

        for (j = 0; j < (MAX_PRIO_NUM + 1); j++) { /* prio */
            if (priv->lag_prio2tc[i][j]) {
                if (!is_printed) {
                    seq_printf(m, "%-6d   %-4d   %-2d\n",
                               i,
                               j,
                               priv->lag_prio2tc[i][j]);
                    is_printed = 1;
                } else {
                    seq_printf(m, "%-6s   %-4d   %-2d\n",
                               "",
                               j,
                               priv->lag_prio2tc[i][j]);
                }
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __vtag_mode_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0, phy_port_max = 0;
    int             i, j;
    u8              is_printed;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "vtag mode dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-7s   %-4s",
                       "sysport", "vlan");

    for (i = 0; i < (phy_port_max + 1); i++) { /* system port */
        is_printed = 0;

        for (j = 0; j < SXD_MAX_VLAN_NUM; j++) { /* vlan */
            if (priv->port_vtag_mode[i][j]) {
                if (!is_printed) {
                    seq_printf(m, "0x%-5x   %-4d\n",
                               i,
                               j);
                    is_printed = 1;
                } else {
                    seq_printf(m, "%-7s   %-4d\n",
                               "",
                               j);
                }
            }
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-6s   %-4s",
                       "LAG ID", "vlan");

    for (i = 0; i < (lag_max + 1); i++) { /* LAG ID */
        is_printed = 0;

        for (j = 0; j < SXD_MAX_VLAN_NUM; j++) { /* vlan */
            if (priv->lag_vtag_mode[i][j]) {
                if (!is_printed) {
                    seq_printf(m, "%-6d   %-4d\n",
                               i,
                               j);
                    is_printed = 1;
                } else {
                    seq_printf(m, "%-6s   %-4d\n",
                               "",
                               j);
                }
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __prio_tag_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0, phy_port_max = 0;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "prio tag dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-7s",
                       "sysport");

    for (i = 0; i < (phy_port_max + 1); i++) { /* system port */
        if (priv->port_prio_tagging_mode[i]) {
            seq_printf(m, "0x%-5x\n", i);
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-6s",
                       "LAG ID");

    for (i = 0; i < (lag_max + 1); i++) { /* LAG ID */
        if (priv->lag_prio_tagging_mode[i]) {
            seq_printf(m, "%-6d\n", i);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __vid_to_ip_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "vid to ip dump");

    print_table_header(m, "%-4s   %-10s",
                       "vlan", "ip");

    for (i = 0; i < (SXD_MAX_VLAN_NUM - 1); i++) { /* vlan */
        if (priv->icmp_vlan2ip_db[i]) {
            seq_printf(m, "%-4d   0x%08x\n",
                       i, priv->icmp_vlan2ip_db[i]);
        }
    }

    print_empty_line(m);
    return 0;
}


static int __vport_rif_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0, phy_port_max = 0;
    int             i, j;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "vport rif dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-5s   %-4s   %-5s",
                       "local", "vlan", "rif");

    for (i = 0; i < (phy_port_max + 1); i++) {
        for (j = 0; j < SXD_MAX_VLAN_NUM; j++) {
            if (priv->port_rp_rif_valid[i][j]) {
                seq_printf(m, "%-5d   %-4d   %-5u\n",
                           i, j, priv->port_rp_rif[i][j]);
            }
        }
    }

    print_empty_line(m);

    print_table_header(m, "%-6s   %-4s   %-5s",
                       "LAG ID", "vlan", "rif");

    for (i = 0; i < lag_max; i++) {
        for (j = 0; j < SXD_MAX_VLAN_NUM; j++) {
            if (priv->lag_rp_rif_valid[i][j]) {
                seq_printf(m, "%-6d   %-4d   %-5u\n",
                           i, j, priv->lag_rp_rif[i][j]);
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __vid_to_fid_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        phy_port_max = 0;
    int             i, j;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "vid to fid dump");

    if (sx_core_get_phy_port_max(dev, &phy_port_max)) {
        seq_printf(m, "failed to get max number of PHY ports.\n");
        return 0;
    }

    print_table_header(m, "%-5s   %-4s   %-5s",
                       "local", "vlan", "fid");

    for (i = 0; i < phy_port_max; i++) {
        for (j = 0; j < SXD_MAX_VLAN_NUM; j++) {
            if (priv->port_vid_to_fid[i][j]) {
                seq_printf(m, "%-5d   %-4d    %-5u\n",
                           i, j, priv->port_vid_to_fid[i][j]);
            }
        }
    }

    print_empty_line(m);
    return 0;
}


static int __lag_oper_state_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;
    uint16_t        lag_max = 0, lag_member_max = 0;
    int             i;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "LAG oper state dump");

    if (sx_core_get_lag_max(dev, &lag_max, &lag_member_max)) {
        seq_printf(m, "failed to get max number of LAGs.\n");
        return 0;
    }

    print_table_header(m, "%-6s   %-10s",
                       "LAG ID", "oper-state");

    for (i = 0; i < lag_max; i++) { /* lag id */
        if (priv->lag_oper_state[i]) {
            seq_printf(m, "%-6d   %-10s\n",
                       i, "up");
        } else {
            seq_printf(m, "%-6d   %-10s\n",
                       i, "down");
        }
    }

    print_empty_line(m);
    return 0;
}


static int __fw_and_board_info_dump(struct seq_file *m, void *v)
{
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct sx_priv *priv;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);

    print_header(m, "FW and BoardInfo dump");

    seq_printf(m, "PSID              : %s\n", dev->board_id);
    seq_printf(m, "FW release version: %d.%d.%04d\n",
               (int)(priv->fw.fw_ver >> 32),
               (int)((priv->fw.fw_ver >> 16) & 0xffff),
               (int)(priv->fw.fw_ver & 0xffff));
    seq_printf(m, "FW release date   : %02x/%02x/%04x %02x:%02x\n",
               priv->fw.fw_day,
               priv->fw.fw_month,
               priv->fw.fw_year,
               priv->fw.fw_hour,
               priv->fw.fw_minutes);

    print_empty_line(m);
    return 0;
}


/* ******************************************************************************* */
/* PROC DUMP INFRA FUNCTIONS                                                       */
/* ******************************************************************************* */

static int __sx_dbg_dump_proc_open(struct inode *inode, struct file *file)
{
    const char      * name = (const char*)PDE_DATA(inode);
    struct proc_info *iter = __name_to_info(name);

    if (!iter) {
        printk(KERN_ERR "could not find proc file '%s' information\n", name);
        return -ENOENT;
    }

    return single_open_size(file, iter->show_cb, NULL, iter->size_cb ? iter->size_cb() : SEQ_FILE_SIZE);
}


int sx_dbg_dump_proc_fs_register(const char *name, dbg_dump_proc_show_cb_t show_cb, dbg_dump_proc_size_cb_t size_cb)
{
    static const struct file_operations __sx_dbg_dump_proc_handler = {
        .owner = THIS_MODULE,
        .open = __sx_dbg_dump_proc_open,
        .read = seq_read,
        .llseek = seq_lseek,
        .release = single_release
    };
    struct proc_dir_entry              *pde;
    struct proc_info                   *proc_info = NULL;
    int                                 err;

    if (!name || !show_cb) {
        printk(KERN_ERR "proc file name is empty or no show handler\n");
        return -EINVAL;
    }

    mutex_lock(&__proc_list_lock);

    if (__name_to_info(name)) {
        printk(KERN_ERR "proc file %s already exists\n", name);
        err = -EEXIST;
        goto error;
    }

    err = -ENOMEM;

    proc_info = kmalloc(sizeof(struct proc_info), GFP_KERNEL);
    if (proc_info == NULL) {
        printk(KERN_WARNING "create info for proc %s failed\n", name);
        goto error;
    }

    proc_info->name = kmalloc(strlen(name) + 1, GFP_KERNEL);
    if (proc_info->name == NULL) {
        printk(KERN_WARNING "allocate name of info for proc %s failed\n", name);
        goto error;
    }

    strcpy(proc_info->name, name);

    pde = proc_create_data(name,
                           S_IFREG | S_IRUGO,
                           __root_dir,
                           &__sx_dbg_dump_proc_handler,
                           (void*)proc_info->name);
    if (pde == NULL) {
        printk(KERN_WARNING "create proc %s failed\n", name);
        goto error;
    }

    INIT_LIST_HEAD(&proc_info->list);
    proc_info->show_cb = show_cb;
    proc_info->size_cb = size_cb;

    list_add(&proc_info->list, &__proc_list);
    printk(KERN_INFO "create proc %s succeeded\n", name);

    err = 0;

out:
    mutex_unlock(&__proc_list_lock);
    return err;

error:
    if (proc_info) {
        if (proc_info->name) {
            kfree(proc_info->name);
        }

        kfree(proc_info);
    }

    goto out;
}


int sx_dbg_ptp_dump_proc_show(struct seq_file *m, void *v);
int sx_dbg_clock_dump_proc_show(struct seq_file *m, void *v);
int sx_dbg_clock_and_ptp_log_dump_proc_show(struct seq_file *m, void *v);

void __sx_dbg_dump_proc_fs_unregister(struct proc_info *proc_info)
{
    list_del(&proc_info->list);
    remove_proc_entry(proc_info->name, __root_dir);
    printk(KERN_INFO "remove proc %s succeeded\n", proc_info->name);
    kfree(proc_info->name);
    kfree(proc_info);
}


void sx_dbg_dump_proc_fs_unregister(const char *name)
{
    struct proc_info *proc_info;

    mutex_lock(&__proc_list_lock);

    proc_info = __name_to_info(name);
    if (proc_info == NULL) {
        printk(KERN_ERR "proc file %s does not exist\n", name);
    } else {
        __sx_dbg_dump_proc_fs_unregister(proc_info);
    }

    mutex_unlock(&__proc_list_lock);
}


int __init sx_dbg_dump_proc_fs_init(void)
{
    const char *proc_dir_name = SX_DBG_DUMP_PROC_DIR;

    sx_dbg_dump_proc_registered = 0;
    if (sx_dbg_dump_proc_registered) {
        return -EEXIST;
    }

    mutex_init(&__proc_list_lock);

    /* Create dbg dump proc directory */
    __root_dir = proc_mkdir(proc_dir_name, NULL);
    if (__root_dir == NULL) {
        printk(KERN_WARNING "create proc dir %s failed\n", proc_dir_name);
        return -ENOMEM;
    }

    sx_dbg_dump_proc_registered = 1;

    sx_dbg_dump_proc_fs_register("trap_reg_dump", __trap_reg_dump, NULL);
    sx_dbg_dump_proc_fs_register("trap_filter_register_dump", __trap_filter_register_dump, NULL);
    sx_dbg_dump_proc_fs_register("host_ifc_stats_dump", __host_ifc_stats_dump, NULL);
    sx_dbg_dump_proc_fs_register("unconsumed_pkt_dump", __unconsumed_pkt_dump, NULL);
    sx_dbg_dump_proc_fs_register("cq_dump", __cq_dump, NULL);
    sx_dbg_dump_proc_fs_register("ber_monitor_dump", __ber_monitor_dump, NULL);
    sx_dbg_dump_proc_fs_register("tele_thrs_dump", __tele_thrs_dump, NULL);
    sx_dbg_dump_proc_fs_register("ptp_dump", sx_dbg_ptp_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("clock_dump", sx_dbg_clock_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("clock_and_ptp_log_dump", sx_dbg_clock_and_ptp_log_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("monitor_rdq_dump", __monitor_rdq_dump, NULL);
    sx_dbg_dump_proc_fs_register("fid_to_hwfid_dump", __fid_to_hwfid_dump, NULL);
    sx_dbg_dump_proc_fs_register("rif_to_hwfid_dump", __rif_to_hwfid_dump, NULL);
    sx_dbg_dump_proc_fs_register("sdq_completion_dump", __sdq_completion_dump, NULL);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
    sx_dbg_dump_proc_fs_register("rdq_to_filter_ebpf_prog_dump", __rdq_to_filter_ebpf_prog_dump, NULL);
#endif
    sx_dbg_dump_proc_fs_register("sys_to_local_dump", __sys_to_local_dump, NULL);
    sx_dbg_dump_proc_fs_register("local_to_sys_dump", __local_to_sys_dump, NULL);
    sx_dbg_dump_proc_fs_register("lag_to_pvid_dump", __lag_to_pvid_dump, NULL);
    sx_dbg_dump_proc_fs_register("lag_member_to_local_dump", __lag_member_to_local_dump, NULL);
    sx_dbg_dump_proc_fs_register("router_port_dump", __router_port_dump, NULL);
    sx_dbg_dump_proc_fs_register("local_to_swid_dump", __local_to_swid_dump, NULL);
    sx_dbg_dump_proc_fs_register("truncate_size_dump", __truncate_size_dump, NULL);
    sx_dbg_dump_proc_fs_register("trap_filter_dump", __trap_filter_dump, NULL);
    sx_dbg_dump_proc_fs_register("prio_to_tc_dump", __prio_to_tc_dump, NULL);
    sx_dbg_dump_proc_fs_register("vtag_mode_dump", __vtag_mode_dump, NULL);
    sx_dbg_dump_proc_fs_register("prio_tag_dump", __prio_tag_dump, NULL);
    sx_dbg_dump_proc_fs_register("vid_to_ip_dump", __vid_to_ip_dump, NULL);
    sx_dbg_dump_proc_fs_register("vport_rif_dump", __vport_rif_dump, NULL);
    sx_dbg_dump_proc_fs_register("vid_to_fid_dump", __vid_to_fid_dump, NULL);
    sx_dbg_dump_proc_fs_register("lag_oper_state_dump", __lag_oper_state_dump, NULL);
    sx_dbg_dump_proc_fs_register("fw_and_board_info_dump", __fw_and_board_info_dump, NULL);
    sx_dbg_dump_proc_fs_register("mmap_dump", sx_mmap_dump, NULL);

    sx_core_counters_init();

    return 0;
}

void sx_dbg_dump_proc_fs_deinit(void)
{
    struct proc_info *iter, *tmp;

    if (sx_dbg_dump_proc_registered == 0) {
        return;
    }

    mutex_lock(&__proc_list_lock);

    list_for_each_entry_safe(iter, tmp, &__proc_list, list) {
        __sx_dbg_dump_proc_fs_unregister(iter);
    }

    mutex_unlock(&__proc_list_lock);

    /* Remove dbg dump proc directory */
    remove_proc_entry(SX_DBG_DUMP_PROC_DIR, NULL);
    sx_dbg_dump_proc_registered = 0;
}
