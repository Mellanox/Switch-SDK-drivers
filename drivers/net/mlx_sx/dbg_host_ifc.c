/*
 * Copyright (C) 2010-2022 NVIDIA CORPORATION & AFFILIATES, Ltd. ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION & AFFILIATES, Ltd.
 * (the "Company") and all right, title, and interest in and to the software product,
 * including all associated intellectual property rights, are and shall
 * remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

#include <linux/module.h>
#include <linux/kallsyms.h>
#include <linux/seq_file.h>
#include "sx.h"
#include "sx_dbg_dump_proc.h"
#include "dev_db.h"

#define DBG_DUMP_BUFF_SIZE       80
#define TRAP_UNKNOWN_STR         "Unknown"
#define TRAP_ACL_OR_ROUTER_STR   "ACL or Router trap"
#define TRAP_ANY_STR             "Any trap"
#define MONITOR_SW_QUEUE_HANDLER "sx_cq_monitor_sw_queue_handler"

extern const char *ku_pkt_type_str[];

/*
 * trap_ids string is defined as static string array because traps range isn't continuous
 */
static const char * const __sxd_trap_id_str_s[] = {
    /* GENERAL */
    [SXD_TRAP_ID_GENERAL_FDB] = "SXD_GENERAL_FDB",           /**< FDB */
    [SXD_TRAP_ID_GENERAL_DR_IPC] = "SXD_DR_IPC",      /**< DR IPC */
    [SXD_TRAP_ID_GENERAL_DR_RES] = "SXD_DR_RES",      /**< DR RES */
    [SXD_TRAP_ID_GENERAL_ETH_EMAD] = "SXD_ETH_EMAD",   /**< ETHERNET EMAD */
    [SXD_TRAP_ID_FDB] = "SXD_FDB",                     /**< FDB TRAP */

    /* EVENTS */
    [SXD_TRAP_ID_PUDE] = "SXD_PUDE",                   /**< port up/down*/
    [SXD_TRAP_ID_PMPE] = "SXD_PMPE",                   /**< port module plug / unplug */
    [SXD_TRAP_ID_FLAE] = "SXD_FLAE",                   /**< FDB learning and aging event */
    [SXD_TRAP_ID_FORE] = "SXD_FORE",                   /**< Fan Out of Rang event generated by hardware */
    [SXD_TRAP_ID_TMPW] = "SXD_TMPW",                   /**< Temperature warning event */
    [SXD_TRAP_ID_CPUWD] = "SXD_CPUWD",                 /**< CPU Watchdog Event */
    [SXD_TRAP_ID_ACCU_FLOW_INC] = "SXD_TRAP_ID_ACCU_FLOW_INC", /**< Accumulated event */
    [SXD_TRAP_ID_PPBME] = "SXD_PPBME",                  /**< BER monitor trap */
    [SXD_TRAP_ID_PACKET_RECEIVED] = "SXD_PACKET_RECEIVED",
    [SXD_TRAP_ID_MFDE] = "SXD_MFDE",                   /**< FW MFDE (FW_SOS) */
    [SXD_TRAP_ID_FSHE] = "SXD_TRAP_ID_FSHE",                   /**< FW FSHE  */
    [SXD_TRAP_ID_MOCS_DONE] = "SXD_TRAP_ID_MOCS_DONE", /**< MOCS DONE (Bulk counters) */
    [SXD_TRAP_ID_MECCC] = "SXD_TRAP_ID_MECCC", /**< MECCC (ECC reporting) */
    [SXD_TRAP_ID_IPAC_DONE] = "SXD_IPAC_ID_MOCS_DONE", /**< IPAC DONE */
    [SXD_TRAP_ID_UTFD] = "SXD_TRAP_ID_UTFD",    /**< UTFD */
    [SXD_TRAP_ID_PPCNT] = "SXD_TRAP_ID_PPCNT", /**< PPCNT (Bulk counters) */
    [SXD_TRAP_ID_MGPCB] = "SXD_TRAP_ID_MGPCB", /**< MGPCB (Bulk counters) */
    [SXD_TRAP_ID_PBSR] = "SXD_TRAP_ID_PBSR", /**< PBSR (Bulk counters) */
    [SXD_TRAP_ID_SBSRD] = "SXD_TRAP_ID_SBSRD", /**< SBSRD (Bulk counters) */
    [SXD_TRAP_ID_CEER] = "SXD_TRAP_ID_CEER", /**< CEER (Bulk counters) */
    [SXD_TRAP_ID_MAFBI] = "SXD_TRAP_ID_MAFBI", /**< MAFBI (Bulk counters) */
    [SXD_TRAP_ID_BULK_COUNTER_DONE_EVENT] = "SXD_TRAP_ID_BULK_COUNTER_DONE_EVENT", /**< MOCS DONE SW Event (Bulk counters) */
    [SXD_TRAP_ID_SB_SNAPSHOT] = "SXD_SB_SNAPSHOT", /**< SB SNAPSHOT EVENT */
    [SXD_TRAP_ID_FSPS] = "SXD_FSPS", /**< Stateful DB trap sent upon crossing partition warning / max threshold. */

    /* ETHERNET L2 */
    [SXD_TRAP_ID_ETH_L2_STP] = "SXD_STP",                /**< ETHERNET L2 STP */
    [SXD_TRAP_ID_ETH_L2_LACP] = "SXD_LACP",               /**< ETHERNET L2 LACP */
    [SXD_TRAP_ID_ETH_L2_EAPOL] = "SXD_EAPOL",              /**< ETHERNET L2 EAPOL */
    [SXD_TRAP_ID_ETH_L2_LLDP] = "SXD_LLDP",               /**< ETHERNET L2 LLDP */
    [SXD_TRAP_ID_ETH_L2_MMRP] = "SXD_MMRP",               /**< ETHERNET L2 MMRP */
    [SXD_TRAP_ID_ETH_L2_MVRP] = "SXD_MVRP",               /**< ETHERNET L2 MVRP */
    [SXD_TRAP_ID_ETH_L2_RPVST] = "SXD_RPVST",              /**< ETHERNET L2 RPVST */

    /* PTP traps */
    [SXD_TRAP_ID_PTP_PTP0] = "SXD_PTP0_EVENT",
    [SXD_TRAP_ID_PTP_PTP1] = "SXD_PTP1_GENERAL",
    [SXD_TRAP_ID_PTP_ING_EVENT] = "SXD_PTP_ING_EVENT",
    [SXD_TRAP_ID_PTP_EGR_EVENT] = "SXD_PTP_EGR_EVENT",
    [SXD_TRAP_ID_MTPPST] = "SXD_TRAP_ID_PTP_CLOCK_PPS_EVENT",

    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_QUERY] = "SXD_IGMP_QUERY",    /**< ETHERNET L2 IGMP QUERY */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V1_REPORT] = "SXD_IGMP_V1_REPORT", /**< ETHERNET L2 IGMP V1_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_REPORT] = "SXD_IGMP_V2_REPORT", /**< ETHERNET L2 IGMP V2_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V3_REPORT] = "SXD_IGMP_V3_REPORT", /**< ETHERNET L2 IGMP V3_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_LEAVE] = "SXD_IGMP_V2_LEAVE", /**< ETHERNET L2 IGMP V2_LEAVE */
    [SXD_TRAP_ID_ETH_L2_UDLD] = "SXD_UDLD",               /**< ETHERNET UDLD */
    [SXD_TRAP_ID_ETH_L2_DHCP] = "SXD_L2_DHCP",               /**< ETHERNET L2 DHCP */
    [SXD_TRAP_ID_ETH_L2_DHCPV6] = "SXD_L2_DHCPV6",               /**< ETHERNET L2 DHCP V6 */
    [SXD_TRAP_ID_ETH_CONF_TYPE0] = "SXD_ETH_CONF_TYPE0",
    [SXD_TRAP_ID_ETH_CONF_TYPE1] = "SXD_ETH_CONF_TYPE1",
    [SXD_TRAP_ID_ETH_L2_PKT_SAMPLE] = "SXD_PACKET_SAMPLE",    /**< ETHERNET L2 PACKET_SAMPLING */
    [SXD_TRAP_ID_FDB_MISS] = "SXD_FDB_MISS",
    [SXD_TRAP_ID_FDB_MISMATCH] = "SXD_FDB_MISMATCH",
    [SXD_TRAP_ID_FID_MISS] = "SXD_FID_MISS",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE0] = "SXD_ICMPV6_CONF_TYPE0",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE1] = "SXD_ICMPV6_CONF_TYPE1",
    [SXD_TRAP_ID_OVERLAY_ICMPV6_CONF_TYPE] = "SXD_OVERLAY_ICMPV6_CONF_TYPE",
    [SXD_TRAP_ID_RARP_OPCODES] = "SXD_RARP_OPCODES",       /**< ETHERNET L2 RARP OPCODES */

    /* FCoE */
    [SXD_TRAP_ID_FCOE_FIP] = "SXD_FCOE_FIP",

    /* Telemetry threshold crossing */
    [SXD_TRAP_ID_SB_CONG_TX_PORT] = "SXD_SB_CONG_TX_PORT",

    /* ECN */
    [SXD_TRAP_ID_DECAP_ECN0] = "SXD_DECAP_ECN0",                /**< NVE/IPinIP/MPLS ECN0 */
    [SXD_TRAP_ID_DECAP_ECN1] = "SXD_DECAP_ECN1",                /**< NVE/IPinIP/MPLS ECN1 */

    /* Router */
    [SXD_TRAP_ID_ARP_REQUEST] = "SXD_ARP_REQUEST",               /**< ARP REQUEST */
    [SXD_TRAP_ID_ARP_RESPONSE] = "SXD_ARP_RESPONSE",              /**< ARP RESPONSE */
    [SXD_TRAP_ID_ETH_L3_MTUERROR] = "SXD_L3_MTUERROR",              /**< Packet exceed router interface MTU */
    [SXD_TRAP_ID_ETH_L3_TTLERROR] = "SXD_L3_TTLERROR",              /**< Time To Live (TTL, Expired */
    [SXD_TRAP_ID_ETH_L3_LBERROR] = "SXD_L3_LBERROR",
    [SXD_TRAP_ID_OSPF] = "SXD_OSPF",
    [SXD_TRAP_ID_RIP_V1] = "SXD_RIP_V1",
    [SXD_TRAP_ID_RIP_V2] = "SXD_RIP_V2",
    [SXD_TRAP_ID_PIM] = "SXD_PIM",
    [SXD_TRAP_ID_VRRP] = "SXD_VRRP",
    [SXD_TRAP_ID_VRRP_IPV6] = "SXD_VRRP_IPV6",
    [SXD_TRAP_ID_RESERVED_MC] = "SXD_RESERVED_MC",
    [SXD_TRAP_ID_IPBC] = "SXD_IPBC",
    [SXD_TRAP_ID_ETH_L3_RPF] = "SXD_L3_RPF",
    [SXD_TRAP_ID_ETH_L3_ASSERT] = "SXD_L3_ASSERT",
    [SXD_TRAP_ID_IP2ME] = "SXD_IP2ME",
    [SXD_TRAP_ID_RTR_INGRESS0] = "SXD_RTR_INGRESS0",
    [SXD_TRAP_ID_RTR_INGRESS1] = "SXD_RTR_INGRESS1",
    [SXD_TRAP_ID_RTR_INGRESS2] = "SXD_RTR_INGRESS2",
    [SXD_TRAP_ID_RTR_INGRESS3] = "SXD_RTR_INGRESS3",
    [SXD_TRAP_ID_RTR_EGRESS0] = "SXD_RTR_EGRESS0",
    [SXD_TRAP_ID_RTR_EGRESS1] = "SXD_RTR_EGRESS1",
    [SXD_TRAP_ID_RTR_EGRESS2] = "SXD_RTR_EGRESS2",
    [SXD_TRAP_ID_RTR_EGRESS3] = "SXD_RTR_EGRESS3",
    [SXD_TRAP_ID_HOST_MISS_IPV4] = "SXD_HOST_MISS_IPV4",
    [SXD_TRAP_ID_HOST_MISS_IPV6] = "SXD_HOST_MISS_IPV6",
    [SXD_TRAP_ID_BFD_IPV4] = "SXD_BFD_IPV4",
    [SXD_TRAP_ID_BFD_IPV6] = "SXD_BFD_IPV6",
    [SXD_TRAP_ID_SSH_IPV4] = "SXD_SSH_IPV4",
    [SXD_TRAP_ID_SSH_IPV6] = "SXD_SSH_IPV6",
    [SXD_TRAP_ID_PING_IPV4] = "SXD_PING_IPV4",
    [SXD_TRAP_ID_PING_IPV6] = "SXD_PING_IPV6",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV4] = "SXD_ROUTER_ALERT_IPV4",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV6] = "SXD_ROUTER_ALERT_IPV6",
    [SXD_TRAP_ID_IPV4_DHCP] = "SXD_IPV4_DHCP",
    [SXD_TRAP_ID_IPV4_SNMP] = "SXD_SNMP_IPV4",
    [SXD_TRAP_ID_IPV6_SNMP] = "SXD_SNMP_IPV6",
    [SXD_TRAP_ID_ROUTER_ARPBC] = "SXD_ROUTER_ARPBC",
    [SXD_TRAP_ID_ROUTER_ARPUC] = "SXD_ROUTER_ARPUC",
    [SXD_TRAP_ID_ROUTER_RARP_OPCODES] = "SXD_ROUTER_RARP",

    /* IPv6 L3 */
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_SIP] = "SXD_IPV6_UNSPEC_SIP",
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_DIP] = "SXD_IPV6_UNSPEC_DIP",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_DST] = "SXD_IPV6_LINK_LOCAL_DST",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_SRC] = "SXD_IPV6_LINK_LOCAL_SRC",
    [SXD_TRAP_ID_IPV6_ALL_NODES_LINK] = "SXD_IPV6_ALL_NODES_LINK",
    [SXD_TRAP_ID_IPV6_OSPF] = "SXD_IPV6_OSPF",
    [SXD_TRAP_ID_IPV6_DHCP] = "SXD_IPV6_DHCP",

    [SXD_TRAP_ID_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    [SXD_TRAP_ID_IPV6_ALL_ROUTERS_LINK] = "SXD_IPV6_ALL_ROUTERS_LINK",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    /* IPv6 L2 */
    [SXD_TRAP_ID_IPV6_MLD_V1_V2] = "SXD_IPV6_MLD_V1_V2",
    [SXD_TRAP_ID_IPV6_MLD_V1_REPORT] = "SXD_IPV6_MLD_V1_REPORT",
    [SXD_TRAP_ID_IPV6_MLD_V1_DONE] = "SXD_IPV6_MLD_V1_DONE",
    [SXD_TRAP_ID_IPV6_MLD_V2_REPORT] = "SXD_IPV6_MLD_V2_REPORT",

    /* InfiniBand */
    [SXD_TRAP_ID_INFINIBAND_QP0] = "SXD_INFINIBAND_QP0",                         /**< IB QP0 */
    [SXD_TRAP_ID_INFINIBAND_QP1] = "SXD_INFINIBAND_QP1",                         /**< IB QP1 */
    [SXD_TRAP_ID_INFINIBAND_OTHER_QPS] = "SXD_INFINIBAND_OTHER_QPS",           /**< IB OTHERS */
    [SXD_TRAP_ID_INFINIBAND_EXTERNAL_SMA] = "SXD_INFINIBAND_EXTERNAL_SMA",      /**< IB External SMA */
    [SXD_TRAP_ID_INFINIBAND_IN_NV_ACCESS_REG] = "SXD_INFINIBAND_IN_NV_ACCESS_REG", /**< IB VS-MAD with ACCESS_REG with one of the NV Config registers */
    [SXD_TRAP_ID_INFINIBAND_IB_FMAD_RCV] = "SXD_INFINIBAND_IB_FMAD_RCV",     /**< IB VS-MAD with ACCESS_REG with one of Config registers */
    [SXD_TRAP_ID_INFINIBAND_RESET_CMD] = "SXD_INFINIBAND_RESET_CMD",       /**< IB RESET CMD */

    /* MPLS */
    [SXD_TRAP_ID_MPLS_ILM_MISS] = "SXD_MPLS_ILM_MISS",
    [SXD_TRAP_ID_MPLS_LDP] = "SXD_MPLS_LDP",
    [SXD_TRAP_ID_MPLS_LB_LSP_PING] = "SXD_LB_LSP_PING",
    [SXD_TRAP_ID_MPLS_ILM0] = "SXD_MPLS_ILM0",
    [SXD_TRAP_ID_MPLS_ILM1] = "SXD_MPLS_ILM1",
    [SXD_TRAP_ID_MPLS_ILM0] = "SXD_MPLS_ILM2",
    [SXD_TRAP_ID_MPLS_ILM1] = "SXD_MPLS_ILM3",
    [SXD_TRAP_ID_MPLS_NHLFE0] = "SXD_MPLS_NHLFE0",
    [SXD_TRAP_ID_MPLS_NHLFE1] = "SXD_MPLS_NHLFE1",
    [SXD_TRAP_ID_MPLS_NHLFE2] = "SXD_MPLS_NHLFE2",
    [SXD_TRAP_ID_MPLS_NHLFE3] = "SXD_MPLS_NHLFE3",

    /* BGP */
    [SXD_TRAP_ID_IPV4_BGP] = "SXD_IPV4_BGP",
    [SXD_TRAP_ID_IPV6_BGP] = "SXD_IPV6_BGP",

    /* SPAN */
    [SXD_TRAP_ID_MIRROR] = "SXD_MIRROR",
    [SXD_TRAP_ID_MIRROR_AGENT0] = "SXD_MIRROR_AGENT0",
    [SXD_TRAP_ID_MIRROR_AGENT1] = "SXD_MIRROR_AGENT1",
    [SXD_TRAP_ID_MIRROR_AGENT2] = "SXD_MIRROR_AGENT2",
    [SXD_TRAP_ID_MIRROR_AGENT3] = "SXD_MIRROR_AGENT3",
    [SXD_TRAP_ID_MIRROR_AGENT4] = "SXD_MIRROR_AGENT4",
    [SXD_TRAP_ID_MIRROR_AGENT5] = "SXD_MIRROR_AGENT5",
    [SXD_TRAP_ID_MIRROR_AGENT6] = "SXD_MIRROR_AGENT6",
    [SXD_TRAP_ID_MIRROR_AGENT7] = "SXD_MIRROR_AGENT7",

    /* Tunneling */
    [SXD_TRAP_ID_DECAP_ENCAP] = "SXD_DECAP_ENCAP",
    [SXD_TRAP_ID_IPIP_DECAP_ERROR] = "SXD_IPIP_DECAP_ERROR",
    [SXD_TRAP_ID_IPIP_ERROR] = "SXD_IPIP_ERROR",
    [SXD_TRAP_ID_NVE_DECAP_IGMP] = "SXD_NVE_DECAP_IGMP",
    [SXD_TRAP_ID_NVE_DECAP_ARP] = "SXD_NVE_DECAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_TAG_ERROR] = "SXD_NVE_DECAP_TAG_ERROR",
    [SXD_TRAP_ID_NVE_IPV4_DHCP] = "SXD_NVE_IPV4_DHCP",
    [SXD_TRAP_ID_NVE_IPV6_DHCP] = "SXD_NVE_IPV6_DHCP",
    [SXD_TRAP_ID_NVE_DECAP_FRAG_ERROR] = "SXD_NVE_DECAP_FRAG_ERROR",
    [SXD_TRAP_ID_NVE_ENCAP_ARP] = "SXD_NVE_ENCAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_ETH] = "SXD_NVE_DECAP_ETH",
    [SXD_TRAP_ID_NVE_DECAP_MLD] = "SXD_NVE_DECAP_MLD",

    /* Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET] = "SXD_DISCARD_ING_PACKET",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH] = "SXD_DISCARD_ING_SWITCH",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH] = "SXD_DISCARD_LOOKUP_SWITCH",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER] = "SXD_DISCARD_ING_ROUTER",
    [SXD_TRAP_ID_DISCARD_ING_LSR] = "SXD_DISCARD_ING_LSR",
    [SXD_TRAP_ID_DISCARD_ROUTER] = "SXD_DISCARD_ROUTER",
    [SXD_TRAP_ID_DISCARD_LSR] = "SXD_DISCARD_LSR",
    [SXD_TRAP_ID_DISCARD_DEC] = "SXD_DISCARD_DEC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH] = "SXD_DISCARD_OVERLAY_SWITCH",
    [SXD_TRAP_ID_DISCARD_ISOLATION] = "SXD_DISCARD_ISOLATION",
    [SXD_TRAP_ID_DISCARD_NON_ROUTED] = "SXD_DISCARD_NON_ROUTED",
    [SXD_TRAP_ID_DISCARD_EGR_LSR] = "SXD_DISCARD_EGR_LSR",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE] = "SXD_DISCARD_MC_SCOPE",
    [SXD_TRAP_ID_DISCARD_ROUTER2] = "SXD_DISCARD_ROUTER2",
    [SXD_TRAP_ID_DISCARD_ROUTER3] = "SXD_DISCARD_ROUTER3",
    [SXD_TRAP_ID_DISCARD_LSR2] = "SXD_DISCARD_LSR2",
    [SXD_TRAP_ID_DISCARD_LSR3] = "SXD_DISCARD_LSR3",

    /* Extended Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_MC] = "SXD_DISCARD_ING_PACKET_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_DMAC] = "SXD_DISCARD_ING_PACKET_SMAC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_RSV_MAC] = "SXD_DISCARD_ING_PACKET_RSV_MAC",

    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VTAG_ALLOW] = "SXD_DISCARD_ING_SWITCH_VTAG_ALLOW",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VLAN] = "SXD_DISCARD_ING_SWITCH_VLAN",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_STP] = "SXD_DISCARD_ING_SWITCH_STP",

    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_UC] = "SXD_DISCARD_LOOKUP_SWITCH_UC",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_MC_NULL] = "SXD_DISCARD_LOOKUP_SWITCH_MC_NULL",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_LB] = "SXD_DISCARD_LOOKUP_SWITCH_LB",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_NO_PORTS] = "SXD_DISCARD_LOOKUP_SWITCH_NO_PORTS",

    [SXD_TRAP_ID_DISCARD_ING_ROUTER_NO_HDR] = "SXD_DISCARD_ING_ROUTER_NO_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LB] = "SXD_DISCARD_ING_ROUTER_DIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_MC] = "SXD_DISCARD_ING_ROUTER_SIP_MC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_CLASS_E] = "SXD_DISCARD_ING_ROUTER_SIP_CLASS_E",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LB] = "SXD_DISCARD_ING_ROUTER_SIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_UNSP] = "SXD_DISCARD_ING_ROUTER_SIP_UNSP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_IP_HDR] = "SXD_DISCARD_ING_ROUTER_IP_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_DIP] = "SXD_DISCARD_ING_ROUTER_SIP_DIP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_BC] = "SXD_DISCARD_ING_ROUTER_SIP_BC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LOCAL_NET] = "SXD_DISCARD_ING_ROUTER_DIP_LOCAL_NET",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_DIP_LINK_LOCAL",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_SIP_LINK_LOCAL",

    [SXD_TRAP_ID_DISCARD_ING_LSR_NO_LABEL] = "SXD_DISCARD_ING_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_ING_LSR_UC_ET] = "SXD_DISCARD_ING_LSR_UC_ET",
    [SXD_TRAP_ID_DISCARD_ING_LSR_MC_DMAC] = "SXD_DISCARD_ING_LSR_MC_DMAC",

    [SXD_TRAP_ID_DISCARD_ROUTER_IRIF_EN] = "SXD_DISCARD_ROUTER_IRIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_EN] = "SXD_DISCARD_ROUTER_ERIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_FWD] = "SXD_DISCARD_ROUTER_ERIF_FWD",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM4] = "SXD_DISCARD_ROUTER_LPM4",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM6] = "SXD_DISCARD_ROUTER_LPM6",

    [SXD_TRAP_ID_DISCARD_LSR_MIN_LABEL] = "SXD_DISCARD_LSR_MIN_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_MAX_LABEL] = "SXD_DISCARD_LSR_MAX_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_LB] = "SXD_DISCARD_LSR_LB",

    [SXD_TRAP_ID_DISCARD_DEC_PKT] = "SXD_DISCARD_DEC_PKT",
    [SXD_TRAP_ID_DISCARD_DEC_DIS] = "SXD_DISCARD_DEC_DIS",

    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_MC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_DMAC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_DMAC",
    [SXD_TRAP_ID_DISCARD_ENC_ISOLATION] = "SXD_TRAP_ID_DISCARD_ENC_ISOLATION",

    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_LABEL] = "SXD_DISCARD_EGR_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_IP] = "SXD_DISCARD_EGR_LSR_NO_IP",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_PHP_NO_IP] = "SXD_DISCARD_EGR_LSR_PHP_NO_IP",

    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_0] = "SXD_DISCARD_MC_SCOPE_IPV6_0",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_1] = "SXD_DISCARD_MC_SCOPE_IPV6_1",

    /* SWITCHX SDK EVENTS */
    [SXD_TRAP_ID_SIGNAL] = "SXD_SW_EV_SIGNAL",             /**< signal trap for SDK internal use */
    [SXD_TRAP_ID_OBJECT_DELETED_EVENT] = "SXD_OBJECT_DELETED_EVENT",
    [SXD_TRAP_ID_PORT_ADDED] = "SXD_PORT_ADDED",
    [SXD_TRAP_ID_PORT_DELETED] = "SXD_PORT_DELETED",
    [SXD_TRAP_ID_PORT_ADDED_TO_LAG] = "SXD_PORT_ADDED_TO_LAG",
    [SXD_TRAP_ID_PORT_REMOVED_FROM_LAG] = "SXD_PORT_REMOVED_FROM_LAG",
    [SXD_TRAP_ID_NEW_DEVICE_ADD] = "SXD_SW_EV_NEW_DEVICE_ADD",                  /**< device add event */
    [SXD_TRAP_ID_MAC_LEARNING_EVENT] = "SXD_SW_EV_MAC_LEARNING_EVENT",              /**< mac learning event */
    [SXD_TRAP_ID_MAC_AGING_EVENT] = "SXD_SW_EV_MAC_AGING_EVENT",                 /**< mac aging event */
    [SXD_TRAP_ID_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NEED_TO_RESOLVE_ARP",             /**< need to resolve ARP  */
    [SXD_TRAP_ID_NO_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NO_NEED_TO_RESOLVE_ARP",          /**< no need to resolve ARP  */
    [SXD_TRAP_ID_FDB_EVENT] = "SXD_SW_EV_FDB_EVENT",                       /**< FDB event */
    [SXD_TRAP_ID_RM_SDK_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_SDK_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_RM_HW_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_HW_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_FDB_SRC_MISS] = "SXD_SW_EV_FDB_SRC_MISS",                    /**< FDB SRC MISS trap */
    [SXD_TRAP_ID_ROUTER_NEIGH_ACTIVITY] = "SXD_SW_EV_ROUTER_NEIGH_ACTIVITY",
    [SXD_TRAP_ID_ASYNC_API_COMPLETE_EVENT] = "SXD_SW_EV_ASYNC_API_COMPLETE_EVENT",
    [SXD_TRAP_ID_ROUTER_MC_ACTIVITY] = "SXD_SW_EV_ROUTER_MC_ACTIVITY",              /**< router mc activity */
    [SXD_TRAP_ID_FDB_IP_ADDR_ACTIVITY] = "SXD_SW_EV_FDB_IP_ADDR_ACTIVITY",            /**< fdb ip addr activity */
    [SXD_TRAP_ID_TRANSACTION_ERROR] = "SXD_SW_EV_TRANSACTION_ERROR",               /**< error in transaction mode */
    [SXD_TRAP_ID_BFD_TIMEOUT_EVENT] = "SXD_SW_EV_BFD_TIMEOUT_EVENT",
    [SXD_TRAP_ID_BFD_PACKET_EVENT] = "SXD_SW_EV_BFD_PACKET_EVENT",
    [SXD_TRAP_ID_SDK_HEALTH_EVENT] = "SXD_SW_SDK_HEALTH_EVENT",


    /* User defined trap ID */
    [SXD_TRAP_ID_IP2ME_CUSTOM0] = "SXD_IP2ME_CUSTOM0",
    [SXD_TRAP_ID_IP2ME_CUSTOM1] = "SXD_IP2ME_CUSTOM1",

    [SXD_TRAP_ID_CONFT_SWITCH0] = "SXD_TRAP_ID_CONFT_SWITCH0",
    [SXD_TRAP_ID_CONFT_SWITCH1] = "SXD_TRAP_ID_CONFT_SWITCH1",
    [SXD_TRAP_ID_CONFT_SWITCH2] = "SXD_TRAP_ID_CONFT_SWITCH2",
    [SXD_TRAP_ID_CONFT_SWITCH3] = "SXD_TRAP_ID_CONFT_SWITCH3",

    [SXD_TRAP_ID_CONFT_ROUTER0] = "SXD_TRAP_ID_CONFT_ROUTER0",
    [SXD_TRAP_ID_CONFT_ROUTER1] = "SXD_TRAP_ID_CONFT_ROUTER1",
    [SXD_TRAP_ID_CONFT_ROUTER2] = "SXD_TRAP_ID_CONFT_ROUTER2",
    [SXD_TRAP_ID_CONFT_ROUTER3] = "SXD_TRAP_ID_CONFT_ROUTER3",

    [SXD_TRAP_ID_CONFT_SWITCH_ENC0] = "SXD_TRAP_ID_CONFT_SWITCH_ENC0",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC1] = "SXD_TRAP_ID_CONFT_SWITCH_ENC1",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC2] = "SXD_TRAP_ID_CONFT_SWITCH_ENC2",
    [SXD_TRAP_ID_CONFT_SWITCH_ENC3] = "SXD_TRAP_ID_CONFT_SWITCH_ENC3",

    [SXD_TRAP_ID_CONFT_SWITCH_DEC0] = "SXD_TRAP_ID_CONFT_SWITCH_DEC0",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC1] = "SXD_TRAP_ID_CONFT_SWITCH_DEC1",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC2] = "SXD_TRAP_ID_CONFT_SWITCH_DEC2",
    [SXD_TRAP_ID_CONFT_SWITCH_DEC3] = "SXD_TRAP_ID_CONFT_SWITCH_DEC3",

    [SXD_TRAP_ID_TSDE] = "SXD_TRAP_ID_TSDE",
    [SXD_TRAP_ID_DSDSC] = "SXD_TRAP_ID_DSDSC",
    [SXD_TRAP_ID_BCTOE] = "SXD_TRAP_ID_BCTOE",
    [SXD_TRAP_ID_PMLPE] = "SXD_TRAP_ID_PMLPE",

    /* SDK Test Traps */
    [SXD_TRAP_ID_SDK_TEST1] = "SXD_TRAP_ID_SDK_TEST1",
    [SXD_TRAP_ID_SDK_TEST2] = "SXD_TRAP_ID_SDK_TEST2",

    [SXD_TRAP_ID_MAX + 1] = "SXD_UNKNOWN",                               /**< MAXIMUM TRAP ID */
};

#define SXD_TRAP_ID_STR_SIZE (sizeof(__sxd_trap_id_str_s) / sizeof(__sxd_trap_id_str_s[0]))

static const char * __trap_id_str(u16 trap_id)
{
    if (trap_id == NUM_HW_SYNDROMES) {
        return TRAP_ANY_STR;
    } else if ((trap_id >= SXD_TRAP_ID_ACL_MIN) && (trap_id <= SXD_TRAP_ID_ACL_MAX)) {
        return TRAP_ACL_OR_ROUTER_STR;
    } else {
        return (trap_id < SXD_TRAP_ID_STR_SIZE && __sxd_trap_id_str_s[trap_id] ?
                __sxd_trap_id_str_s[trap_id] : TRAP_UNKNOWN_STR);
    }
}

static inline int SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(u64 *arr, u32 num)
{
    int idx = (num) / 64;
    u64 bit = (1ULL << ((num) % 64));

    return ((arr)[idx] & (bit)) ? 1 : 0;
}

static inline int SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(u64 *arr, u32 size)
{
    int i = 0;

    for (i = 0; i < size; i++) {
        if (arr[i] != 0) {
            return 0;
        }
    }
    return 1;
}

static void __print_listener(struct seq_file *m, u16 synd, struct listener_entry           *listener)
{
    static char                               handler_name[KSYM_SYMBOL_LEN] = "";
    static char                               source_name[DBG_DUMP_BUFF_SIZE] = "";
    static char                               uc_name[DBG_DUMP_BUFF_SIZE] = "";
    static char                               type_name[DBG_DUMP_BUFF_SIZE] = "";
    static char                               type_crit[DBG_DUMP_BUFF_SIZE] = "";
    static char                               reg_key_name[DBG_DUMP_BUFF_SIZE] = "";
    const struct sx_psample_listener_context *psample_ctx;
    char                                     *end;
    struct sx_rsc                            *file = NULL;
    int                                       mon_rdq = RDQ_INVALID_ID;
    unsigned long                             flags;

    memset(handler_name, 0, sizeof(handler_name));
    memset(uc_name, 0, sizeof(uc_name));
    memset(type_name, 0, sizeof(type_name));
    memset(type_crit, 0, sizeof(type_crit));
    memset(reg_key_name, 0, sizeof(reg_key_name));

    sprint_symbol(handler_name, (unsigned long)listener->handler);
    end = strchr(handler_name, '+');
    if (end) {
        *end = '\0';
    }

    if (strstr(handler_name, "sx_netdev_handle_pude_event")) {
        strcpy(uc_name, "PUDE");
    } else if (strstr(handler_name, "sx_ib_handle_rx_pkt")
               || strstr(handler_name, "sx_ib_rpa_handle_rx_pkt")
               || strstr(handler_name, "sx_netdev_handle_global_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_cq_handler")) {
        strcpy(uc_name, "FD");
    } else if (strstr(handler_name, "sx_netdev_handle_rx_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_log_port_rx_pkt")) {
        strcpy(uc_name, "LOG_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_phy_port_rx_pkt")) {
        strcpy(uc_name, "PHY_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_l2_tunnel_handler")) {
        strcpy(uc_name, "L2_TUNNEL");
    } else if (strstr(handler_name, "psample")) {
        psample_ctx = (struct sx_psample_listener_context*)listener->context;
        snprintf(uc_name, sizeof(uc_name) - 1, "PSAMPLE [g=%u,rc=%u]",
                 psample_ctx->group_num, psample_ctx->refcnt);
    } else {
        strncpy(uc_name, handler_name, sizeof(uc_name) - 1);
    }

    switch (listener->listener_type) {
    case L2_TYPE_DONT_CARE:
        strcpy(type_name, "Don't Care");
        if (listener->critireas.dont_care.sysport != SYSPORT_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", sysport %d", listener->critireas.dont_care.sysport);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_IB:
        strcpy(type_name, "IB");
        if (listener->critireas.ib.qpn != QPN_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", qpn %d", listener->critireas.ib.qpn);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_ETH:
        strcpy(type_name, "ETH");
        if (listener->critireas.eth.ethtype != ETHTYPE_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", ethtype 0x%x", listener->critireas.eth.ethtype);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.dmac != DMAC_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", dmac 0x%llx", listener->critireas.eth.dmac);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.emad_tid != TID_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", emad_tid 0x%x", listener->critireas.eth.emad_tid);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_rp != IS_RP_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_rp %d", listener->critireas.eth.from_rp);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_bridge != IS_BRIDGE_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_bridge %d", listener->critireas.eth.from_bridge);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_FC:
        strcpy(type_name, "FC");
        break;

    default:
        strcpy(type_name, "NA");
    }

    if (listener->pid || listener->pname[0]) {
        snprintf(source_name, DBG_DUMP_BUFF_SIZE, "%u/%s", (u32)listener->pid, listener->pname);
    } else {
        source_name[0] = '\0';
    }


    /* print mon_rdq if callback is sx_cq_monitor_sw_queue_handler */
    if (strstr(uc_name, MONITOR_SW_QUEUE_HANDLER) &&
        (listener->context != NULL) &&
        (((struct file *)(listener->context))->private_data != NULL)) {
        file = ((struct file *)(listener->context))->private_data;
        if (file != NULL) {
            spin_lock_irqsave(&file->lock, flags);
            if (file->bound_monitor_rdq != NULL) {
                mon_rdq = file->bound_monitor_rdq->dqn;
            }
            spin_unlock_irqrestore(&file->lock, flags);
        }

        seq_printf(m, "%-30s | %-8d | %-4u | %-21s | %-12s | %-25s | %-15llu | %u | mon_rdq: %d \n",
                   __trap_id_str(synd),
                   synd,
                   listener->swid,
                   source_name,
                   uc_name,
                   type_name,
                   listener->rx_pkts,
                   listener->is_default,
                   mon_rdq);
    } else {
        seq_printf(m, "%-30s | %-8d | %-4u | %-21s | %-12s | %-25s | %-15llu | %u  \n",
                   __trap_id_str(synd),
                   synd,
                   listener->swid,
                   source_name,
                   uc_name,
                   type_name,
                   listener->rx_pkts,
                   listener->is_default);
    }
}

static bool __dev_iterator_trap_reg_dump(struct sx_dev *dev, void *context)
{
    struct sx_dev_db_iterator_seq_file_context *dec = (struct sx_dev_db_iterator_seq_file_context*)context;
    struct sx_priv                             *priv = sx_priv(dev);
    struct listeners_and_rf_info               *info = NULL;
    struct listener_entry                      *listener;
    struct list_head                           *pos;
    unsigned long                               flags;
    u16                                         synd = 0;

    sx_dbg_dump_print_header(dec->m, "Device Trap Registration");

    sx_dbg_dump_print_table_header(dec->m, "%-30s | %-8s | %-4s | %-21s | %-12s | %-25s | %-15s | %s",
                                   "Trap Name", "Trap ID", "SWID", "PID/Name", "User Channel", "Type", "RX packets",
                                   "Is default");

    spin_lock_irqsave(&priv->listeners_and_rf_db.lock, flags);
    info = priv->listeners_and_rf_db.info;

    if (!info) {
        goto out;
    }

    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        if (!list_empty(&info->per_synd_list[synd])) {
            list_for_each(pos, &info->per_synd_list[synd]) {
                listener = list_entry(pos, struct listener_entry, list);
                __print_listener(dec->m, synd, listener);
            }
        }
    }

out:
    spin_unlock_irqrestore(&priv->listeners_and_rf_db.lock, flags);
    sx_dbg_dump_print_empty_line(dec->m);
    return true;
}

static int __trap_reg_dump(struct seq_file *m, void *v, void *context)
{
    struct sx_dev_db_iterator_seq_file_context dec = {
        .m = m,
        .v = v,
        .context = context
    };

    sx_dev_db_iterate(__dev_iterator_trap_reg_dump, &dec);
    return 0;
}

static bool __dev_iterator_trap_filter_reg_dump(struct sx_dev *dev, void *context)
{
    struct sx_dev_db_iterator_seq_file_context *dec = (struct sx_dev_db_iterator_seq_file_context*)context;
    struct sx_priv                             *priv = sx_priv(dev);
    struct listeners_and_rf_info               *info = NULL;
    struct listener_entry                      *listener;
    struct list_head                           *pos;
    unsigned long                               flags;
    u16                                         synd = 0;
    int                                         i = 0;

    sx_dbg_dump_print_header(dec->m, "Device Trap Registrations and Filters");

    spin_lock_irqsave(&priv->listeners_and_rf_db.lock, flags);
    info = priv->listeners_and_rf_db.info;

    if (!info) {
        goto out;
    }

    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        if (!list_empty(&info->per_synd_list[synd])) {
            list_for_each(pos, &info->per_synd_list[synd]) {
                sx_dbg_dump_print_table_header(dec->m,
                                               "%-30s | %-8s | %-4s | %-21s | %-12s | %-25s | %-15s | %s",
                                               "Trap Name",
                                               "Trap ID",
                                               "SWID",
                                               "PID/Name",
                                               "User Channel",
                                               "Type",
                                               "RX packets",
                                               "Is default");
                listener = list_entry(pos, struct listener_entry, list);
                __print_listener(dec->m, synd, listener);
                sx_dbg_dump_print_empty_line(dec->m);

                sx_dbg_dump_print_table_header(dec->m, "%s", "listener Reg/Filter info:");

                seq_printf(dec->m, "%s", "Global Filter: ");
                listener->listener_register_filter.is_global_filter ? seq_printf(dec->m, "%s", "True") : seq_printf(
                    dec->m,
                    "%s",
                    "False");

                seq_printf(dec->m, "%s", "\nPorts Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.ports_filters,
                                                         FROM_BITS_TO_U64(MAX_PHYPORT_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 1; i < MAX_PHYPORT_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.ports_filters,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }

                seq_printf(dec->m, "%s", "\nVlans Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.vlans_filters,
                                                         FROM_BITS_TO_U64(SXD_MAX_VLAN_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 0; i < SXD_MAX_VLAN_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.vlans_filters,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }

                seq_printf(dec->m, "%s", "\nLags Filters: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.lags_filters,
                                                         FROM_BITS_TO_U64(MAX_LAG_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_LAG_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.lags_filters,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }

                seq_printf(dec->m, "%s", "\nGlobal Register: ");
                listener->listener_register_filter.is_global_register ? seq_printf(dec->m, "%s", "True") : seq_printf(
                    dec->m,
                    "%s",
                    "False");

                seq_printf(dec->m, "%s", "\nPorts Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.ports_registers,
                                                         FROM_BITS_TO_U64(MAX_PHYPORT_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.ports_registers,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }

                seq_printf(dec->m, "%s", "\nVlans Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.vlans_registers,
                                                         FROM_BITS_TO_U64(SXD_MAX_VLAN_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 0; i < SXD_MAX_VLAN_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.vlans_registers,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }

                seq_printf(dec->m, "%s", "\nLags Registers: ");
                if (SX_DBG_DUMP_REGISTER_FILTER_IS_CLEAR(listener->listener_register_filter.lags_registers,
                                                         FROM_BITS_TO_U64(MAX_LAG_NUM + 1))) {
                    seq_printf(dec->m, "%s", "None");
                } else {
                    for (i = 0; i < MAX_LAG_NUM + 1; i++) {
                        if (SX_DBG_DUMP_REGISTER_FILTER_BIT_IS_SET(listener->listener_register_filter.lags_registers,
                                                                   i)) {
                            seq_printf(dec->m, " %u|", i);
                        }
                    }
                }
                sx_dbg_dump_print_empty_line(dec->m);
                sx_dbg_dump_print_empty_line(dec->m);
                sx_dbg_dump_print_separate_line(dec->m);
            }
        }
    }

out:
    spin_unlock_irqrestore(&priv->listeners_and_rf_db.lock, flags);
    sx_dbg_dump_print_empty_line(dec->m);
    return true;
}

static int __trap_filter_register_dump(struct seq_file *m, void *v, void *context)
{
    struct sx_dev_db_iterator_seq_file_context dec = {
        .m = m,
        .v = v,
        .context = context
    };

    sx_dev_db_iterate(__dev_iterator_trap_filter_reg_dump, &dec);
    return 0;
}

static bool __dev_iterator_host_ifc_stats_dump(struct sx_dev *dev, void *context)
{
    struct sx_dev_db_iterator_seq_file_context *dec = (struct sx_dev_db_iterator_seq_file_context*)context;
    struct sx_priv                             *priv;
    int                                         pkt_type, synd, rdq;
    char                                        header[SX_DBG_DUMP_HEADER_MAX_LEN];

    priv = sx_priv(dev);

    snprintf(header, SX_DBG_DUMP_HEADER_MAX_LEN, "host-ifc stats dump - device_id %u", dev->device_id);
    sx_dbg_dump_print_header(dec->m, header);


    sx_dbg_dump_print_table_header(dec->m, "%-30s   %-15s",
                                   "RX-type", "RX-packets");

    for (pkt_type = 0; pkt_type < PKT_TYPE_NUM; pkt_type++) {
        if (priv->stats.rx_by_pkt_type[0][pkt_type]) {
            seq_printf(dec->m, "%-30s   %-15llu\n",
                       sx_cqe_packet_type_str[pkt_type],
                       priv->stats.rx_by_pkt_type[0][pkt_type]);
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);

    sx_dbg_dump_print_table_header(dec->m, "%-30s   %-15s   %-15s",
                                   "TX-type", "TX-packets", "TX-bytes");

    for (pkt_type = 0; pkt_type < PKT_TYPE_NUM; pkt_type++) {
        if (priv->stats.tx_by_pkt_type[0][pkt_type]) {
            seq_printf(dec->m, "%-30s   %-15llu   %-15llu\n",
                       ku_pkt_type_str[pkt_type],
                       priv->stats.tx_by_pkt_type[0][pkt_type],
                       priv->stats.tx_by_pkt_type_bytes[0][pkt_type]);
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);

    sx_dbg_dump_print_table_header(dec->m, "%-4s   %-15s   %-15s",
                                   "trap", "RX-packets", "RX-bytes");

    for (synd = 0; synd < NUM_HW_SYNDROMES; synd++) {
        if (priv->stats.rx_by_synd[0][synd]) {
            seq_printf(dec->m, "%-4d   %-15llu   %-15llu\n",
                       synd,
                       priv->stats.rx_by_synd[0][synd],
                       priv->stats.rx_by_synd_bytes[0][synd]);
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);

    sx_dbg_dump_print_table_header(dec->m, "%-3s   %-15s   %-15s",
                                   "RDQ", "RX-packets", "RX-bytes");

    for (rdq = 0; rdq < NUMBER_OF_RDQS; rdq++) {
        if (priv->stats.rx_by_rdq[0][rdq]) {
            seq_printf(dec->m, "%-3d   %-15llu   %-15llu\n",
                       rdq,
                       priv->stats.rx_by_rdq[0][rdq],
                       priv->stats.rx_by_rdq_bytes[0][rdq]);
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);
    return true;
}

static int __host_ifc_stats_dump(struct seq_file *m, void *v, void *context)
{
    struct sx_dev_db_iterator_seq_file_context dec = {
        .m = m,
        .v = v,
        .context = context
    };

    sx_dev_db_iterate(__dev_iterator_host_ifc_stats_dump, &dec);
    return 0;
}

static bool __dev_iterator_unconsumed_pkt_dump(struct sx_dev *dev, void *context)
{
    struct sx_dev_db_iterator_seq_file_context *dec = (struct sx_dev_db_iterator_seq_file_context*)context;
    struct sx_priv                             *priv = NULL;
    u16                                         synd = 0;
    u64                                         total_cnt = 0;
    int                                         pkt_ind = 0;
    char                                        header[SX_DBG_DUMP_HEADER_MAX_LEN];

    priv = sx_priv(dev);

    snprintf(header, SX_DBG_DUMP_HEADER_MAX_LEN, "Unconsumed packets - device_id %u", dev->device_id);
    sx_dbg_dump_print_header(dec->m, header);

    sx_dbg_dump_print_table_header(dec->m, "%-40s|%-8s| %s",
                                   "Trap Name", "Trap ID", "Total Unconsumed packets");

    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        total_cnt = 0;
        for (pkt_ind = 0; pkt_ind < PKT_TYPE_NUM; pkt_ind++) {
            total_cnt = total_cnt + priv->stats.rx_unconsumed_by_synd[synd][pkt_ind];
        }
        if (total_cnt > 0) {
            seq_printf(dec->m, "%-40s|%-8d| %llu\n", __trap_id_str(synd), synd, total_cnt);
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);
    return true;
}

static int __unconsumed_pkt_dump(struct seq_file *m, void *v, void *context)
{
    struct sx_dev_db_iterator_seq_file_context dec = {
        .m = m,
        .v = v,
        .context = context
    };

    sx_dev_db_iterate(__dev_iterator_unconsumed_pkt_dump, &dec);
    return 0;
}

static bool __dev_iterator_trap_filter_dump(struct sx_dev *dev, void *context)
{
    struct sx_dev_db_iterator_seq_file_context *dec = (struct sx_dev_db_iterator_seq_file_context*)context;
    struct sx_priv                             *priv;
    u8                                          printed;
    int                                         i, j;
    char                                        header[SX_DBG_DUMP_HEADER_MAX_LEN];

    priv = sx_priv(dev);

    snprintf(header, SX_DBG_DUMP_HEADER_MAX_LEN, "trap filter dump - device_id %u", dev->device_id);
    sx_dbg_dump_print_header(dec->m, header);

    sx_dbg_dump_print_table_header(dec->m, "%-40s   %-7s   %-7s",
                                   "trap-name", "trap-id", "sysport");

    for (i = 0; i < NUM_HW_SYNDROMES; i++) { /* trap id */
        printed = 0;

        for (j = 0; j < MAX_SYSTEM_PORTS_IN_FILTER; j++) { /* system port */
            if (priv->sysport_filter_db[i][j] != 0) {
                if (!printed) {
                    seq_printf(dec->m, "%-40s   %-7d   0x%-5x\n",
                               __trap_id_str(i),
                               i,
                               priv->sysport_filter_db[i][j]);
                    printed = 1;
                } else {
                    seq_printf(dec->m, "%-40s   %-7s   0x%-5x\n",
                               "",
                               "",
                               priv->sysport_filter_db[i][j]);
                }
            }
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);

    sx_dbg_dump_print_table_header(dec->m, "%-40s   %-7s   %-6s",
                                   "trap-name", "trap-id", "LAG ID");

    for (i = 0; i < NUM_HW_SYNDROMES; i++) { /* trap id */
        printed = 0;

        for (j = 0; j < MAX_LAG_PORTS_IN_FILTER; j++) { /* system port */
            if (priv->lag_filter_db[i][j] != LAG_ID_INVALID) {
                if (!printed) {
                    seq_printf(dec->m, "%-40s   %-7d   %-6d\n",
                               __trap_id_str(i),
                               i,
                               priv->lag_filter_db[i][j]);
                    printed = 1;
                } else {
                    seq_printf(dec->m, "%-40s   %-7s   %-6d\n",
                               "",
                               "",
                               priv->lag_filter_db[i][j]);
                }
            }
        }
    }

    sx_dbg_dump_print_empty_line(dec->m);
    return true;
}

static int __trap_filter_dump(struct seq_file *m, void *v, void *context)
{
    struct sx_dev_db_iterator_seq_file_context dec = {
        .m = m,
        .v = v,
        .context = context
    };

    sx_dev_db_iterate(__dev_iterator_trap_filter_dump, &dec);
    return 0;
}

int sx_dbg_host_ifc_init(void)
{
    sx_dbg_dump_read_handler_register("trap_reg_dump", __trap_reg_dump, NULL, NULL);
    sx_dbg_dump_read_handler_register("trap_filter_register_dump", __trap_filter_register_dump, NULL, NULL);
    sx_dbg_dump_read_handler_register("host_ifc_stats_dump", __host_ifc_stats_dump, NULL, NULL);
    sx_dbg_dump_read_handler_register("unconsumed_pkt_dump", __unconsumed_pkt_dump, NULL, NULL);
    sx_dbg_dump_read_handler_register("trap_filter_dump", __trap_filter_dump, NULL, NULL);
    return 0;
}

void sx_dbg_host_ifc_deinit(void)
{
    sx_dbg_dump_read_handler_unregister("trap_reg_dump");
    sx_dbg_dump_read_handler_unregister("trap_filter_register_dump");
    sx_dbg_dump_read_handler_unregister("host_ifc_stats_dump");
    sx_dbg_dump_read_handler_unregister("unconsumed_pkt_dump");
    sx_dbg_dump_read_handler_unregister("trap_filter_dump");
}
